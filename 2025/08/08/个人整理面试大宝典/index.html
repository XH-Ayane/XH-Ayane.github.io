<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>个人整理面试大宝典 | XHAYANEの小屋</title><meta name="author" content="XH-Ayane"><meta name="copyright" content="XH-Ayane"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="个人整理面试超级大宝典 源自于JAVA面试宝典，个人学习笔记等，整合出来的用于面试使用的终极面试大纲，希望可以通过面试  经过再三考虑，考虑到时间成本等关系，所以我打算采用难点补充来完善这份笔记，所以简单的，或者我认为没有什么必要去归纳在这个文章里面的我就不做进来了   重点会集中放在集合，反射，序列化，多线程&amp;并发，JVM，String，spring boot，Mybatis &#x3D;&#x3D;这个里">
<meta property="og:type" content="article">
<meta property="og:title" content="个人整理面试大宝典">
<meta property="og:url" content="http://xhayane.top/2025/08/08/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%AE%9D%E5%85%B8/index.html">
<meta property="og:site_name" content="XHAYANEの小屋">
<meta property="og:description" content="个人整理面试超级大宝典 源自于JAVA面试宝典，个人学习笔记等，整合出来的用于面试使用的终极面试大纲，希望可以通过面试  经过再三考虑，考虑到时间成本等关系，所以我打算采用难点补充来完善这份笔记，所以简单的，或者我认为没有什么必要去归纳在这个文章里面的我就不做进来了   重点会集中放在集合，反射，序列化，多线程&amp;并发，JVM，String，spring boot，Mybatis &#x3D;&#x3D;这个里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/09/20/u2w8Q45TqcpyLej.png">
<meta property="article:published_time" content="2025-08-08T14:25:00.000Z">
<meta property="article:modified_time" content="2025-08-11T14:25:00.000Z">
<meta property="article:author" content="XH-Ayane">
<meta property="article:tag" content="面试大宝典">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/09/20/u2w8Q45TqcpyLej.png"><link rel="shortcut icon" href="https://s2.loli.net/2024/09/20/u2w8Q45TqcpyLej.png"><link rel="canonical" href="http://xhayane.top/2025/08/08/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%AE%9D%E5%85%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: XH-Ayane","link":"链接: ","source":"来源: XHAYANEの小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '个人整理面试大宝典',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-11 14:25:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/custom.css"media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><span id="fps"></span><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/09/20/u2w8Q45TqcpyLej.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-paperclip"></i><span> 常用资源站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://vercel.com/"><i class="fa-fw fas fa-globe"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://app.rainyun.com/auth/login"><i class="fa-fw fas fa-cloud"></i><span> 雨云云服务器</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://smms.app/"><i class="fa-fw fas fa-inbox"></i><span> 在线图床</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-toolbox"></i><span> 快捷工具站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.runoob.com/"><i class="fa-fw fas fa-book-open-reader"></i><span> 菜鸟工具</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.skyvpnx.com/"><i class="fa-fw fas fa-globe"></i><span> VPN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://convertio.co/zh/"><i class="fa-fw fas fa-arrows-rotate"></i><span> 文件转换器</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://markdown.com.cn/editor/"><i class="fa-fw fas fa-pen"></i><span> 在线makedown编辑器</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fontawesome.com/icons?from=io"><i class="fa-fw fas fa-cube"></i><span> fontawesome</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2024/11/05/Ilzbr3XJBLg9e4S.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="XHAYANEの小屋"><span class="site-name">XHAYANEの小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-paperclip"></i><span> 常用资源站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://vercel.com/"><i class="fa-fw fas fa-globe"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://app.rainyun.com/auth/login"><i class="fa-fw fas fa-cloud"></i><span> 雨云云服务器</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://smms.app/"><i class="fa-fw fas fa-inbox"></i><span> 在线图床</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-toolbox"></i><span> 快捷工具站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.runoob.com/"><i class="fa-fw fas fa-book-open-reader"></i><span> 菜鸟工具</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.skyvpnx.com/"><i class="fa-fw fas fa-globe"></i><span> VPN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://convertio.co/zh/"><i class="fa-fw fas fa-arrows-rotate"></i><span> 文件转换器</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://markdown.com.cn/editor/"><i class="fa-fw fas fa-pen"></i><span> 在线makedown编辑器</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fontawesome.com/icons?from=io"><i class="fa-fw fas fa-cube"></i><span> fontawesome</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">个人整理面试大宝典</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-08T14:25:00.000Z" title="发表于 2025-08-08 14:25:00">2025-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-11T14:25:00.000Z" title="更新于 2025-08-11 14:25:00">2025-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%93%E6%9E%84%E9%80%9F%E6%9F%A5/">结构速查</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>113分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="个人整理面试大宝典"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="个人整理面试超级大宝典"><a href="#个人整理面试超级大宝典" class="headerlink" title="个人整理面试超级大宝典"></a>个人整理面试超级大宝典</h1><blockquote>
<p>源自于JAVA面试宝典，个人学习笔记等，整合出来的用于面试使用的终极面试大纲，希望可以通过面试</p>
<blockquote>
<p>经过再三考虑，考虑到时间成本等关系，所以我打算采用难点补充来完善这份笔记，所以简单的，或者我认为没有什么必要去归纳在这个文章里面的我就不做进来了</p>
</blockquote>
</blockquote>
<p><strong>重点会集中放在集合，反射，序列化，多线程&amp;并发，JVM，String，spring boot，Mybatis</strong></p>
<p>==这个里面的内容必须！必须！必须！全部背记熟练，而且可以做出延伸和联系==</p>
<p>[toc]</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h4 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h4><p>类的设计原则有七个，包括：<strong>开闭原则</strong>、<strong>里氏代换原则</strong>、<strong>迪米特原则（最少知道原则）</strong>、<strong>单一职责原则</strong>、<strong>接口分隔原则</strong>、<strong>依赖倒置原则</strong>、<strong>组合/聚合复用原则</strong>。</p>
<h3 id="什么是B-S架构，什么是C-S架构"><a href="#什么是B-S架构，什么是C-S架构" class="headerlink" title="什么是B/S架构，什么是C/S架构"></a>什么是B/S架构，什么是C/S架构</h3><ol>
<li>B/S(Browser/Server)，浏览器/服务器</li>
<li>C/S(Client/Server)，客户端/服务器</li>
</ol>
<h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><p>面向对象<br>跨平台<br>可靠安全<br>支持多线程</p>
<p><strong>JDK（Java Development Kit）是开发工具包（含编译器），JRE（Java Runtime Environment）是运行环境（含JVM），JVM（Java Virtual Machine）是执行字节码的虚拟机。</strong></p>
<ul>
<li><strong>JDK</strong> = 开发工具（javac等） + <strong>JRE</strong></li>
<li><strong>JRE</strong> = 运行库 + <strong>JVM</strong></li>
<li><strong>JVM</strong> = 执行Java程序的虚拟引擎</li>
</ul>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p><strong>面向过程：</strong>是一种以过程为中心的编程思想。把事情拆分成几个步骤，然后按照一定的顺序执行。<br><strong>面向过程：</strong>就是把现实中的事物都抽象为“对象”。每个对象是唯一的，且都可以拥有它的属性与行为。我们就可以通过调用这些对象的方法、属性去解决问题</p>
<h3 id="java中常见的数据结构"><a href="#java中常见的数据结构" class="headerlink" title="java中常见的数据结构"></a>java中常见的数据结构</h3><blockquote>
<p>什么是数据结构，数据结构是指，计算机保存，组织数据的方式</p>
</blockquote>
<p><strong>在java中的数据结构有以下几种：</strong></p>
<p>1.线性表（ArrayList）<br>2.链表（LinkedList）<br>3.栈（Stack）<br>4.队列（Queue）<br>5.图（Map）<br>6.树（Tree</p>
<h3 id="java中的几种数据类型"><a href="#java中的几种数据类型" class="headerlink" title="java中的几种数据类型"></a>java中的几种数据类型</h3><p><strong>基本数据类型：</strong><br>整形：byte,short,int,long<br>浮点型：float,double<br>字符型：char<br>布尔型：boolean<br><strong>引用数据类型：</strong><br>类（Class）、接口（Interface）、数组（Array）</p>
<h3 id="讲讲什么是显示转换，什么是隐式转换"><a href="#讲讲什么是显示转换，什么是隐式转换" class="headerlink" title="讲讲什么是显示转换，什么是隐式转换"></a>讲讲什么是显示转换，什么是隐式转换</h3><p>显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。</p>
<h3 id="什么是拆装箱机制？什么是包装类？为什么要使用包装类"><a href="#什么是拆装箱机制？什么是包装类？为什么要使用包装类" class="headerlink" title="什么是拆装箱机制？什么是包装类？为什么要使用包装类"></a>什么是拆装箱机制？什么是包装类？为什么要使用包装类</h3><p>装箱就是自动将基本数据类型转换为包装器类型，通过调用方法integer的<code>valueOf</code>方法，拆箱就是自动将包装器类型转换为基本数据类型，与装箱相反</p>
<p><strong>java中的包装类都是哪些</strong></p>
<p>byte：Byte，short：Short，int：Integer，long：Long，float：Float，double：Double，char：Character ，boolean：Boolean</p>
<p><strong>一个java类中包含哪些内容</strong></p>
<p>属性、方法、内部类、构造方法、代码块。</p>
<h3 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h3><h4 id="1-抽象-Abstraction"><a href="#1-抽象-Abstraction" class="headerlink" title="1. 抽象 (Abstraction)"></a>1. 抽象 (Abstraction)</h4><p>抽象是将一类对象的共同特征提取出来构造类的过程，包括：</p>
<ul>
<li><strong>数据抽象</strong>：提取对象的属性</li>
<li><strong>行为抽象</strong>：提取对象的方法</li>
</ul>
<p>特点：</p>
<ul>
<li>只关注对象”有什么”属性和行为，不关注”如何实现”</li>
<li>例如：定义”汽车”类时，只关心它有”颜色”、”品牌”等属性和”启动”、”加速”等方法，不关心这些方法的具体实现</li>
</ul>
<h4 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装 (Encapsulation)"></a>2. 封装 (Encapsulation)</h4><p>封装是将数据和操作数据的方法绑定在一起，并隐藏内部实现细节：</p>
<ul>
<li>对数据的访问只能通过定义好的接口</li>
<li>隐藏一切可隐藏的实现细节，只暴露必要的接口</li>
</ul>
<p>特点：</p>
<ul>
<li>提高了安全性和易用性</li>
<li>例如：全自动洗衣机封装了所有洗衣流程，用户只需按几个按钮</li>
</ul>
<h4 id="3-继承-Inheritance"><a href="#3-继承-Inheritance" class="headerlink" title="3. 继承 (Inheritance)"></a>3. 继承 (Inheritance)</h4><p>继承是从已有类派生出新类的机制：</p>
<ul>
<li>被继承的类称为父类/超类/基类</li>
<li>新类称为子类/派生类</li>
</ul>
<p>特点：</p>
<ul>
<li>子类继承父类的属性和方法</li>
<li>可以实现代码复用和扩展</li>
<li>是封装程序中可变因素的重要手段</li>
</ul>
<h4 id="4-多态-Polymorphism"><a href="#4-多态-Polymorphism" class="headerlink" title="4. 多态 (Polymorphism)"></a>4. 多态 (Polymorphism)</h4><p>多态是指同一操作作用于不同对象可以有不同的行为表现：</p>
<h4 id="多态类型"><a href="#多态类型" class="headerlink" title="多态类型"></a>多态类型</h4><ol>
<li><strong>编译时多态（静态多态）</strong>：<ul>
<li>通过方法重载(overload)实现</li>
<li>在编译时确定调用哪个方法</li>
</ul>
</li>
<li><strong>运行时多态（动态多态）</strong>：<ul>
<li>通过方法重写(override)实现</li>
<li>在运行时根据对象类型确定调用哪个方法</li>
</ul>
</li>
</ol>
<h4 id="实现多态的条件"><a href="#实现多态的条件" class="headerlink" title="实现多态的条件"></a>实现多态的条件</h4><ol>
<li>方法重写（子类重写父类方法）</li>
<li>对象造型（父类引用指向子类对象）</li>
</ol>
<h4 id="多态示例"><a href="#多态示例" class="headerlink" title="多态示例"></a>多态示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Animal &#123;</span><br><span class="line">    void sound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void sound() &#123;</span><br><span class="line">        System.out.println(&quot;汪汪汪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void sound() &#123;</span><br><span class="line">        System.out.println(&quot;喵喵喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal a1 = new Dog();  // 父类引用指向子类对象</span><br><span class="line">        Animal a2 = new Cat();  // 父类引用指向子类对象</span><br><span class="line">        </span><br><span class="line">        a1.sound();  // 输出&quot;汪汪汪&quot;</span><br><span class="line">        a2.sound();  // 输出&quot;喵喵喵&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问修饰符public，private-protected-以及不写时的区别？"><a href="#访问修饰符public，private-protected-以及不写时的区别？" class="headerlink" title="访问修饰符public，private,protected,以及不写时的区别？"></a>访问修饰符public，private,protected,以及不写时的区别？</h3><div class="table-container">
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>protected</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr>
<td>default</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>private</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody>
</table>
</div>
<p>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开（public），对于不是同一个包中的其他类相当于私有（private）。受保护 （protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的 修饰符可以是以上四种。</p>
<h3 id="String是最基本的数据类型吗？"><a href="#String是最基本的数据类型吗？" class="headerlink" title="String是最基本的数据类型吗？"></a>String是最基本的数据类型吗？</h3><p>不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、 char，boolean；除了基本类型（primitie type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用型。</p>
<h3 id="方法重写-Override-与方法重载-Overload-的区别"><a href="#方法重写-Override-与方法重载-Overload-的区别" class="headerlink" title="方法重写(Override)与方法重载(Overload)的区别"></a>方法重写(Override)与方法重载(Overload)的区别</h3><h4 id="方法重写-Override"><a href="#方法重写-Override" class="headerlink" title="方法重写(Override)"></a>方法重写(Override)</h4><p><strong>定义</strong></p>
<p>在子类中重新定义父类已有的方法，方法签名完全相同但实现不同。</p>
<p><strong>特点</strong></p>
<ol>
<li><strong>作用范围</strong>：发生在父类与子类之间（继承关系）</li>
<li><strong>方法签名：</strong><ul>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>返回类型相同或为父类方法返回类型的子类（协变返回类型）</li>
</ul>
</li>
<li><strong>访问权限：</strong><ul>
<li>子类方法的访问修饰符不能比父类更严格</li>
<li>即访问权限要≥父类方法（public &gt; protected &gt; default &gt; private）</li>
</ul>
</li>
<li><strong>异常处理：</strong><ul>
<li>不能抛出比父类方法更宽泛的检查异常</li>
<li>可以抛出相同、更具体或不抛出检查异常</li>
</ul>
</li>
<li><strong>其他限制：</strong><ul>
<li>不能重写被final、static或private修饰的方法</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override  // 使用@Override注解可帮助编译器检查是否正确重写</span><br><span class="line">    public void makeSound() &#123;  // 访问权限扩大(protected→public)</span><br><span class="line">        System.out.println(&quot;汪汪汪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法重载-Overload"><a href="#方法重载-Overload" class="headerlink" title="方法重载(Overload)"></a>方法重载(Overload)</h4><p><strong>定义</strong></p>
<p>在同一个类中，多个方法使用相同名称但参数列表不同。</p>
<p><strong>特点</strong></p>
<ol>
<li><strong>作用范围</strong>：发生在同一个类中（或父子类之间）</li>
<li><strong>方法签名</strong>：<ul>
<li>方法名相同</li>
<li>参数列表必须不同（类型、数量或顺序不同）</li>
</ul>
</li>
<li><strong>返回类型</strong>：<ul>
<li>可以相同也可以不同</li>
<li>不能仅通过返回类型不同来区分重载方法</li>
</ul>
</li>
<li><strong>访问权限</strong>：可以任意修改，没有限制</li>
<li><strong>异常处理</strong>：可以抛出任意异常，没有限制</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">    // 参数数量不同</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int add(int a, int b, int c) &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 参数类型不同</span><br><span class="line">    public double add(double a, double b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 参数顺序不同</span><br><span class="line">    public String concat(String a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String concat(int a, String b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写与重载的关键区别"><a href="#重写与重载的关键区别" class="headerlink" title="重写与重载的关键区别"></a>重写与重载的关键区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>重写(Override)</th>
<th>重载(Overload)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用范围</strong></td>
<td>不同类（父子类）</td>
<td>同一个类</td>
</tr>
<tr>
<td><strong>方法签名</strong></td>
<td>必须完全相同</td>
<td>必须参数列表不同</td>
</tr>
<tr>
<td><strong>返回类型</strong></td>
<td>相同或子类</td>
<td>可以不同</td>
</tr>
<tr>
<td><strong>访问权限</strong></td>
<td>不能比父类更严格</td>
<td>可以任意修改</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>不能抛出更宽泛的检查异常</td>
<td>可以抛出任意异常</td>
</tr>
<tr>
<td><strong>多态类型</strong></td>
<td>运行时多态（动态绑定）</td>
<td>编译时多态（静态绑定）</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>改变已有方法的行为</td>
<td>提供同一功能的不同实现方式</td>
</tr>
</tbody>
</table>
</div>
<h4 id="记忆技巧"><a href="#记忆技巧" class="headerlink" title="记忆技巧"></a>记忆技巧</h4><ul>
<li><strong>重写</strong>：垂直关系（父子类），”覆盖”父类方法</li>
<li><strong>重载</strong>：水平关系（同类中），”扩展”方法功能</li>
</ul>
<h3 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h3><h4 id="（运算符）"><a href="#（运算符）" class="headerlink" title="==（运算符）"></a>==（运算符）</h4><ul>
<li><strong>比较什么</strong>：内存地址（引用类型）或原始值（基本类型）</li>
<li><strong>特点：</strong><ul>
<li>引用类型：判断是否同一个对象</li>
<li>基本类型：直接比较数值</li>
<li>对Integer等包装类：-128~127有缓存，之外是新对象</li>
</ul>
</li>
</ul>
<h4 id="equals-（方法）"><a href="#equals-（方法）" class="headerlink" title="equals()（方法）"></a>equals()（方法）</h4><ul>
<li><strong>比较什么</strong>：对象内容（需重写）</li>
<li><strong>特点：</strong><ul>
<li>默认行为同==（比较地址）</li>
<li>通常需要重写（如String、Integer已重写）</li>
<li>必须与hashCode()一起重写</li>
</ul>
</li>
</ul>
<h4 id="✅-黄金法则"><a href="#✅-黄金法则" class="headerlink" title="✅ 黄金法则"></a>✅ 黄金法则</h4><ol>
<li><strong>永远用equals()比较对象内容</strong></li>
<li><strong>常量放前面防NPE</strong>：<code>&quot;abc&quot;.equals(str)</code></li>
<li><strong>基本类型用==，对象用equals()</strong></li>
<li><strong>阿里规范禁止用==比较对象</strong></li>
</ol>
<h4 id="⚠️-典型陷阱"><a href="#⚠️-典型陷阱" class="headerlink" title="⚠️ 典型陷阱"></a>⚠️ 典型陷阱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 100, b = 100; </span><br><span class="line">a == b; // true（缓存）</span><br><span class="line"></span><br><span class="line">Integer c = 200, d = 200;  </span><br><span class="line">c == d; // false（非缓存）</span><br><span class="line">c.equals(d); // true ✅</span><br></pre></td></tr></table></figure>
<h3 id="java的各种数据默认值"><a href="#java的各种数据默认值" class="headerlink" title="java的各种数据默认值"></a>java的各种数据默认值</h3><ul>
<li>Byte,short,int,long默认是都是0</li>
<li>Boolean默认值是false</li>
<li>Char类型的默认值是’’</li>
<li>Float与double类型的默认是0.0</li>
<li>对象类型的默认值是null</li>
</ul>
<h3 id="java常用包有哪些"><a href="#java常用包有哪些" class="headerlink" title="java常用包有哪些"></a>java常用包有哪些</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java.lang</span><br><span class="line">Java.io</span><br><span class="line">Java.sql</span><br><span class="line">Java.util</span><br><span class="line">Java.awt</span><br><span class="line">Java.net</span><br><span class="line">Java.math</span><br></pre></td></tr></table></figure>
<h3 id="java中的是值传递还是引用传递"><a href="#java中的是值传递还是引用传递" class="headerlink" title="java中的是值传递还是引用传递"></a>java中的是值传递还是引用传递</h3><p>理论上说，java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。对于对象类型，传递是对象的引用，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。</p>
<h3 id="形参与实参的区别"><a href="#形参与实参的区别" class="headerlink" title="形参与实参的区别"></a>形参与实参的区别</h3><h4 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h4><ul>
<li><strong>形参(parameter)</strong>：函数定义时声明的虚拟变量，用于接收传入值</li>
<li><strong>实参(argument)</strong>：函数调用时传入的具体值或表达式</li>
</ul>
<h4 id="五大核心区别"><a href="#五大核心区别" class="headerlink" title="五大核心区别"></a>五大核心区别</h4><ol>
<li><strong>生命周期不同</strong><ul>
<li>形参：函数调用时创建，调用结束销毁</li>
<li>实参：在调用前必须已存在且有确定值</li>
</ul>
</li>
<li><strong>内存关系</strong><ul>
<li>基本类型：形参是实参的副本（值传递）</li>
<li>引用类型：形参复制实参的引用地址（共享对象）</li>
</ul>
</li>
<li><strong>数据流向</strong><ul>
<li>单向传递：只能实参→形参</li>
<li>形参修改不影响实参（除非操作引用对象的属性）</li>
</ul>
</li>
<li><strong>匹配规则</strong><ul>
<li>数量、类型、顺序必须严格一致</li>
<li>自动类型转换仅适用于基本类型</li>
</ul>
</li>
<li><strong>使用场景</strong><ul>
<li>形参：只能在函数体内使用</li>
<li>实参：可以是常量/变量/表达式/函数返回值</li>
</ul>
</li>
</ol>
<h3 id="Java关键方法（Object类）"><a href="#Java关键方法（Object类）" class="headerlink" title="Java关键方法（Object类）"></a>Java关键方法（Object类）</h3><ul>
<li><code>equals()</code>：对象相等比较</li>
<li><code>hashCode()</code>：哈希值生成</li>
<li><code>toString()</code>：对象字符串表示</li>
<li><code>wait()/notify()</code>：线程通信</li>
<li><code>clone()</code>：对象复制</li>
<li><code>getClass()</code>：获取运行时类</li>
</ul>
<h3 id="值传递-vs-引用传递"><a href="#值传递-vs-引用传递" class="headerlink" title="值传递 vs 引用传递"></a>值传递 vs 引用传递</h3><ul>
<li><p><strong>基本类型</strong>：值传递（形参修改不影响实参）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void change(int a) &#123; a = 100; &#125;</span><br><span class="line">int x = 1;</span><br><span class="line">change(x); // x仍为1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用类型</strong>：传递引用地址（可修改对象属性）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void changeName(Person p) &#123; p.name = &quot;Tom&quot;; &#125;</span><br><span class="line">Person obj = new Person();</span><br><span class="line">changeName(obj); // obj.name变为&quot;Tom&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Stetic关键字有什么作用？"><a href="#Stetic关键字有什么作用？" class="headerlink" title="Stetic关键字有什么作用？"></a>Stetic关键字有什么作用？</h3><ul>
<li>Static可以修饰内部类、方法、变量、代码块</li>
<li>Static修饰的类是静态内部类</li>
<li>Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不被重写，可以直接使用类名来调用。</li>
<li>在static方法中不能使用this或者super关键字。</li>
<li>Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。</li>
<li>Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。</li>
</ul>
<h3 id="final在java中的作用，有哪些用法？"><a href="#final在java中的作用，有哪些用法？" class="headerlink" title="final在java中的作用，有哪些用法？"></a>final在java中的作用，有哪些用法？</h3><ol>
<li>被fifinal修饰的类不可以被继承</li>
<li>被fifinal修饰的方法不可以被重写</li>
<li>被fifinal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</li>
<li>被fifinal修饰的方法,JVM会尝试将其内联,以提高运行效率</li>
<li>被fifinal修饰的常量,在编译阶段会存入常量池中.</li>
</ol>
<h3 id="StringString-StringBuffffer-和-StringBuilder-的区别是什么？"><a href="#StringString-StringBuffffer-和-StringBuilder-的区别是什么？" class="headerlink" title="StringString StringBuffffer 和 StringBuilder 的区别是什么？"></a>StringString StringBuffffer 和 StringBuilder 的区别是什么？</h3><p>在 Java 中，<strong>StringBuilder</strong> 和 <strong>StringBuffer</strong> 都是用于修改字符串的类，与 <strong>String</strong> 类不同，它们的对象可以被多次修改，而不会生成新的未使用对象。</p>
<p><strong>线程安全性</strong></p>
<p><strong>StringBuffer</strong> 是线程安全的，因为它的所有公开方法都使用了 <em>synchronized</em> 关键字进行同步。这意味着多个线程可以安全地访问同一个 <strong>StringBuffer</strong> 实例。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized StringBuffer append(String str) &#123;</span><br><span class="line"></span><br><span class="line">// 代码实现</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而 **StringBuilder** 则不是线程安全的，它的公开方法没有使用 *synchronized* 关键字。例如：</span><br><span class="line"></span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line"></span><br><span class="line">// 代码实现</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，在单线程环境下，建议使用 <strong>StringBuilder</strong>，因为它的性能比 <strong>StringBuffer</strong> 更高。</p>
<p><strong>性能</strong></p>
<p>由于 <strong>StringBuilder</strong> 没有同步机制，所以它的性能优于 <strong>StringBuffer</strong>。在需要高性能且不涉及多线程的情况下，<strong>StringBuilder</strong> 是更好的选择。</p>
<p><strong>缓冲区</strong></p>
<p><strong>StringBuffer</strong> 在每次调用 <em>toString</em> 方法时，会直接使用缓存区的 <em>toStringCache</em> 值来构造一个字符串。而 <strong>StringBuilder</strong> 每次都需要复制一次字符数组，再构造一个字符串。</p>
<h3 id="String类的常用方法有哪些？"><a href="#String类的常用方法有哪些？" class="headerlink" title="String类的常用方法有哪些？"></a>String类的常用方法有哪些？</h3><ul>
<li>charAt：返回指定索引处的字符</li>
<li>indexOf()：返回指定字符的索引</li>
<li>replace()：字符串替换</li>
<li>trim()：去除字符串两端空白</li>
<li>split()：分割字符串，返回一个分割后的字符串数组</li>
<li>getBytes()：返回字符串的byte类型数组</li>
<li>length()：返回字符串长度</li>
<li>toLowerCase()：将字符串转成小写字母</li>
<li>toUpperCase()：将字符串转成大写字符</li>
<li>substring()：截取字符串</li>
<li>format()：格式化字符串</li>
<li>equals()：字符串比较</li>
</ul>
<h3 id="java中的继承是单继承还是多继承"><a href="#java中的继承是单继承还是多继承" class="headerlink" title="java中的继承是单继承还是多继承"></a>java中的继承是单继承还是多继承</h3><p>Java中既有单继承，又有多继承。对于java类来说只能有一个父类，对于接口来说可以同时继承多个接口</p>
<h3 id="Super与this表示什么？"><a href="#Super与this表示什么？" class="headerlink" title="Super与this表示什么？"></a>Super与this表示什么？</h3><p>Super表示当前类的父类对象</p>
<p>This表示当前类的对象</p>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别?"></a>抽象类和接口的区别?</h3><p><strong>抽象类：</strong></p>
<ol>
<li>抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类必须重写这些抽象方法。</li>
<li>包含抽象方法的类，一定是抽象类。</li>
<li>抽象类只能被继承，一个类只能继承一个抽象类。</li>
</ol>
<p><strong>接口：</strong></p>
<ol>
<li>全部的方法都是抽象方法，属性都是常量</li>
<li>不能实例化，可以定义变量。</li>
<li>接口变量可以引用具体实现类的实例</li>
<li>接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法</li>
<li>接口之间可以多实现</li>
<li>一个具体类可以实现多个接口，实现多继承现象</li>
</ol>
<h3 id="Hashcode的作用"><a href="#Hashcode的作用" class="headerlink" title="Hashcode的作用"></a>Hashcode的作用</h3><p>hashCode() 是一个Java中的方法，它返回对象的哈希码（hash code）。hashCode是由对象根据其特征属性计算得出的一个整数值。它用于快速识别对象并在哈希表等数据结构中进行高效的存储和检索。</p>
<ul>
<li><h3 id="hashcode的实现机制"><a href="#hashcode的实现机制" class="headerlink" title="hashcode的实现机制"></a>hashcode的实现机制</h3><p>hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
</li>
<li><h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><p>HashMap 的<strong>底层用的是数组</strong>。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素；除此之外，容量的提升也会相应地提高查询效率，因为”桶（坑）”更多了嘛，原来需要通过链表存储的（查询的时候需要遍历），扩容后可能就有自己专属的”坑位”了（直接就能查出来）。</p>
<p>数组是<strong>无法自动扩容</strong> 的，所以如果要扩容的话，就需要新建一个大的数组，然后把之前小的数组的元素复制过去，并且要<strong>重新计算哈希值和重新分配桶（重新散列</strong>），这个过程也是挺耗时的。</p>
<p><strong>HashMap 的扩容是通过resize 方法 来实现的，JDK 8 中融入了红黑树</strong></p>
<blockquote>
<p>一句话总结出来就是，当我们往 HashMap 中不断添加元素时，HashMap 会自动进行扩容操作（条件是元素数量达到负载因子（load factor）乘以数组长度时），以保证其存储的元素数量不会超出其容量限制。</p>
<p>在进行扩容操作时，HashMap 会先将数组的长度扩大一倍，然后将原来的元素重新散列到新的数组中。</p>
<p>由于元素的位置是通过 key 的 hash 和数组长度进行与运算得到的，因此在数组长度扩大后，元素的位置也会发生一些改变。一部分索引不变，另一部分索引为”原索引+旧容量”。</p>
</blockquote>
</li>
</ul>
<h3 id="java创建对象的方式有？"><a href="#java创建对象的方式有？" class="headerlink" title="java创建对象的方式有？"></a>java创建对象的方式有？</h3><ol>
<li><p>new创建新对象</p>
</li>
<li><p>通过反射机制</p>
</li>
<li><p>采用clone机制</p>
</li>
<li><p>通过序列化机制</p>
</li>
</ol>
<h3 id="拷贝和浅拷贝的区别是什么"><a href="#拷贝和浅拷贝的区别是什么" class="headerlink" title="拷贝和浅拷贝的区别是什么"></a>拷贝和浅拷贝的区别是什么</h3><blockquote>
<p>我的记忆方法是，一个诛九族，一个杀自己</p>
</blockquote>
<p><strong>浅拷贝:</strong><br>被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.<br><strong>深拷贝:</strong><br>被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</p>
<h3 id="final、finalize-、finally"><a href="#final、finalize-、finally" class="headerlink" title="final、finalize()、finally"></a>final、finalize()、finally</h3><p>这三个长的挺像的吧……</p>
<p><strong>性质不同</strong></p>
<ol>
<li>final为关键字；</li>
<li>finalize()为方法；</li>
<li>finally为区块标志，用于try语句中；</li>
</ol>
<p><strong>作用</strong></p>
<ol>
<li>final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；</li>
<li>finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用<br> 户自定义时，用于释放对象占用的资源（比如进行I/0操作）；</li>
<li>finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进<br> 行；</li>
</ol>
<p>==注意在回答的时候请务必展开到final的具体用法上==</p>
<h3 id="JDBC操作的步骤"><a href="#JDBC操作的步骤" class="headerlink" title="JDBC操作的步骤"></a>JDBC操作的步骤</h3><p>加载数据库驱动类<br>打开数据库连接<br>执行sql语句<br>处理返回结果<br>关闭资源</p>
<h3 id="在使用jdbc的时候，如何防止出现sql注入的问题。"><a href="#在使用jdbc的时候，如何防止出现sql注入的问题。" class="headerlink" title="在使用jdbc的时候，如何防止出现sql注入的问题。"></a>在使用jdbc的时候，如何防止出现sql注入的问题。</h3><p>使用PreparedStatement类，而不是使用Statement类即可</p>
<h3 id="是否了解连接池，使用连接池的好处"><a href="#是否了解连接池，使用连接池的好处" class="headerlink" title="是否了解连接池，使用连接池的好处"></a>是否了解连接池，使用连接池的好处</h3><blockquote>
<p>所有的池子作用基本上都差不多，所以一定要公式化记忆，并答出具体的内容</p>
</blockquote>
<p>可以说：通过预先创建并维护一定数量的数据库连接，减少频繁创建和销毁连接的开销，提升系统性能和资源利用率。</p>
<p>数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。</p>
<p><strong>连接池的作用</strong></p>
<ol>
<li>减少资源消耗：避免每次数据库操作都创建新连接。 </li>
<li>提升性能：预分配的连接可快速响应请求，降低等待时间。 </li>
<li>优化资源利用：通过连接池统一管理连接的生命周期，避免无效连接占用资源。</li>
</ol>
<h3 id="TCP和DUP的区别"><a href="#TCP和DUP的区别" class="headerlink" title="TCP和DUP的区别"></a>TCP和DUP的区别</h3><p>TCP：传输控制协议，他是一种面向连接的传输层协议，能够提供高可靠性的通信。</p>
<p>能够保证数据无误，无丢失，无失序，无重复。</p>
<p>适用情况：</p>
<p>1、适合于对传输质量要求较高，以及传输大量数据的通信。</p>
<p>2、在需要可靠数据传输的场合，通常使用TCP协议</p>
<p>3、MSN/QQ等即时通讯软件的用户登录账户管理相关的功能通常采用TCP协议</p>
<p>UDP：用户数据报协议，提供的是非面向连接的、不可靠的数据流传输。</p>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<p>UDP不提供可靠性，也不提供报文到达确认、排序以及流量控制等功能。他只是把应用程序传给IP层的数据报发送出去，但是不能保证他们能到达目的地。因此报文可能会丢失、重复以及乱序等。在数据发送前不需要连接，所以可以进行高效率通信，适合于广播/组播式通信中。</p>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>第一次握手：客户通过调用connect进行主动打开(active open)。这引起客户TCP发送一个SYN（表示同步）分节（SYN=J），它告诉服务器客户将在连接中发送到数据的初始序列号。并进入SYN_SEND状态，等待服务器的确认。</p>
<p>第二次握手：服务器必须确认客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器以单个字节向客户发送SYN和对客户SYN的ACK（表示确认），此时服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户收到服务器的SYN+ACK。向服务器发送确认分节，此分节发送完毕，客户服务器进入ESTABLISHED状态，完成三次握手。</p>
<h3 id="tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="tcp 为什么要三次握手，两次不行吗？为什么？"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h3><p>TCP采用三次握手是为了确保连接的可靠性和防止历史连接导致的资源浪费，两次握手无法满足这些需求：<br>通过三次交互确认双方的收发能力。第一次握手验证客户端的发送能力；第二次握手验证服务端的收发能力；第三次握手最终确认客户端的接收能力。</p>
<h3 id="GET请求和POST请求区别"><a href="#GET请求和POST请求区别" class="headerlink" title="GET请求和POST请求区别"></a>GET请求和POST请求区别</h3><ul>
<li><strong>Post和Get的共同点：</strong><br>①都是HTTP协议中的两个发送请求的方法，底层都是 <strong>基于TCP/IP协议</strong> 。</li>
<li><strong>post</strong><ul>
<li>①post传递数据，不需要在url中显式出来，而get方法需要在 url中显式 。<br>②post传输的 数据量大，可以达到2M ，而get传参受url长度限制， 最多传递1024字节 。<br>③post请求是 将数据传输到服务器端 ，而get请求是为了 从服务器端取数据（为什么get也能传参？为了告诉服务端需要什么数据）<br>④post在真正接受数据之前会 先将请求头发送给服务器进行确认，然后才真正发送数据 。</li>
</ul>
</li>
<li><strong>Get</strong><ul>
<li>①get传递的参数在页面可以看见，安全性低。（post更安全，不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）<br>②GET请求请求 参数在请求行中，没有请求体 。POST请求请求 参数在请求体中 。<br>③get传参 速度更快 。<br>④get不能 传递中文，会乱码 ，而post不会出现乱码问题。</li>
</ul>
</li>
</ul>
<h3 id="什么是TomCat"><a href="#什么是TomCat" class="headerlink" title="什么是TomCat?"></a>什么是TomCat?</h3><p>Tomcat是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖于Tomcat才能运行。</p>
<h3 id="什么是Servlet？Servlet由谁来创建？Servlet方法由谁调用？"><a href="#什么是Servlet？Servlet由谁来创建？Servlet方法由谁调用？" class="headerlink" title="什么是Servlet？Servlet由谁来创建？Servlet方法由谁调用？"></a>什么是Servlet？Servlet由谁来创建？Servlet方法由谁调用？</h3><p>Servlet是Java提供的一门 动态web 资源开发技术，Servlet由web服务器创建，Servlet方法由web服务器调用。</p>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><p>对象的生命周期指一个对象从被创建到被销毁的整个过程。<br>Servlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段：<br>① 加载和实例化：默认情况下，当servlet第一次被访问时，由容器创建servlet对象。<br>② 初始化：在Servlet实例化之后，容器将调用servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次。<br>③ 请求处理：每次请求servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。<br>④ 服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</p>
<h3 id="什么是请求转发"><a href="#什么是请求转发" class="headerlink" title="什么是请求转发"></a>什么是请求转发</h3><p>请求转发（forward）：一种在 服务器内部的资源跳转方式。<br>实现方式req.getRequestDispatcher(“资源B路径”).forward(req,resp)；<br>请求转发资源间共享数据：使用Request对象 void setAttribute(String name,Object o)：存储数据到request域中。 Object getAttribute(String name)：根据key，获取值。 void removeAttribute(String name)：根据key，删除该键值对。</p>
<h3 id="请求转发的特点"><a href="#请求转发的特点" class="headerlink" title="请求转发的特点"></a>请求转发的特点</h3><p>① 浏览器地址栏路径不发生变化。<br>② 只能转发到当前服务器的内部资源。<br>③ 一次请求，可以在转发的资源间使用request共享数据。</p>
<h3 id="请求重定向的特点"><a href="#请求重定向的特点" class="headerlink" title="请求重定向的特点"></a>请求重定向的特点</h3><p>① 浏览器地址栏路径发生变化。<br>② 可以重定向到任意位置的资源（服务器内部、外部均可）。<br>③ 两次请求，不能在多个资源使用request共享数据。</p>
<h3 id="Cookie-amp-Session的用途和区别"><a href="#Cookie-amp-Session的用途和区别" class="headerlink" title="Cookie &amp; Session的用途和区别"></a>Cookie &amp; Session的用途和区别</h3><p>Cookie和Session都是来完成一次会话内多次请求间 数据共享 的。<br>区别：</p>
<p>存储位置：Cookie是将数据存储在客户端，Session 将数据存储在服务端。<br>安全性：Cookie 不安全，Session安全。<br>数据大小：Cookie最大3KB，Session无大小限制。<br>存储时间：Cookie可以长期存储，Session 默认30分钟。<br>服务器性能：Cookie不占服务器资源，Session占用服务器资源。</p>
<h3 id="Filter是什么，什么作用？"><a href="#Filter是什么，什么作用？" class="headerlink" title="Filter是什么，什么作用？"></a>Filter是什么，什么作用？</h3><ul>
<li>概念：Filter表示过滤器，是JavaWeb三大组件（Servlet、Filter、Listener）之一。</li>
<li>过滤器可以把对资源的请求 拦截 下来，从而实现一些特殊的功能。</li>
<li>过滤器一般完成一些 通用的操作 ，比如：权限控制、统一编码处理、敏感字符处理等等。</li>
</ul>
<h3 id="Listener是什么？有什么作用？"><a href="#Listener是什么？有什么作用？" class="headerlink" title="Listener是什么？有什么作用？"></a>Listener是什么？有什么作用？</h3><ul>
<li>概念：Listener表示监听器，是JavaWeb三大组件（Servlet、Filter、Listener）之一。</li>
<li>监听器可以监听就是在application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</li>
</ul>
<h3 id="AJAX是什么？有什么作用？"><a href="#AJAX是什么？有什么作用？" class="headerlink" title="AJAX是什么？有什么作用？"></a>AJAX是什么？有什么作用？</h3><p>AJAX（Asynchronous JavaScript And XML）：<strong>异步</strong> 的JavaScript和XML。</p>
<p>AJAX作用：<br>① 与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据。（使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了）<br>② 异步交互：可以在 不重新加载整个页面 的情况下，与服务器交换数据并 更新部分网页 的技术，如：搜索联想、用户名是否可用校验等。</p>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><strong>应用层（Application Layer）：</strong>这是网络体系结构中的最顶层，提供用户接口和应用程序之间的通信服务。在这一层，用户可以访问各种网络应用程序，如电子邮件、文件传输和远程登录。<br><strong>表示层（Presentation Layer）：</strong>该层负责数据的格式化、加密和压缩，以确保数据在不同系统之间的交换是有效的和安全的。它还提供了数据格式转换和语法转换的功能。\<br><strong>会话层（Session Layer）：</strong>会话层管理应用程序之间的通信会话，负责建立、维护和终止会话。它还提供了数据的同步和检查点恢复功能，以确保通信的完整性和持续性。<br><strong>传输层（Transport Layer）：</strong>传输层为应用程序提供端到端的数据传输服务，负责数据的分段、传输控制、错误恢复和流量控制。它主要使用 TCP（传输控制协议）和 UDP（用户数据报协议）来实现这些功能。<br><strong>网络层（Network Layer）：</strong>网络层负责数据包的路由和转发，以及网络中的寻址和拥塞控制。它选择最佳的路径来传输数据包，以确保它们能够从源主机到目标主机进行传输。<br><strong>数据链路层（Data Link Layer）：</strong>数据链路层提供点对点的数据传输服务，负责将原始比特流转换为数据帧，并检测和纠正传输中出现的错误。它还控制访问物理媒介的方式，以及数据帧的传输和接收。<br><strong>物理层（Physical Layer）：</strong>物理层在物理媒介上传输原始比特流，定义了连接主机的硬件设备和传输媒介的规范。它确保比特流能够在网络中准确地传输，例如通过以太网、光纤和无线电波等媒介。</p>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><p><strong>应用层（Application Layer）</strong>类似于 OSI 模型中的应用层，负责处理用户与网络应用程序之间的通信。它包括诸如 HTTP、FTP、SMTP 等协议，用于实现不同类型的网络服务和应用。<br><strong>传输层（Transport Layer）：</strong>与 OSI 模型中的传输层相对应，提供端到端的数据传输服务。在 TCP/IP 模型中，主要有两个协议：TCP（传输控制协议）和 UDP（用户数据报协议），用于确保可靠的数据传输和简单的数据传输。<br><strong>网络层（Internet Layer）</strong>：相当于 OSI 模型中的网络层，负责数据包的路由和转发。它使用 IP（Internet Protocol）协议来定义数据包的传输路径，并处理不同网络之间的通信。<br><strong>网络接口层（Link Layer）</strong>：与 OSI 模型中的数据链路层和物理层相对应，负责管理网络硬件设备和物理媒介之间的通信。它包括以太网、Wi-Fi、蓝牙等各种物理层和数据链路层协议。</p>
<h3 id="静态内部类如何定义，什么叫成员内部类"><a href="#静态内部类如何定义，什么叫成员内部类" class="headerlink" title="静态内部类如何定义，什么叫成员内部类"></a>静态内部类如何定义，什么叫成员内部类</h3><p><strong>定义在类内部的静态类，就是静态内部类。</strong></p>
<ol>
<li>静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。</li>
<li>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</li>
<li>其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：Out.Inner inner = new Out.Inner();inner.print();</li>
<li>Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</li>
</ol>
<p><strong>定义在类内部的非静态类，就是成员内部类。</strong></p>
<p>成员内部类不能定义静态方法和变量（final修饰的除外）。这是因为成员内部类是非静态的，<br>类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</p>
<h3 id="排序都有哪几种方法？请列举"><a href="#排序都有哪几种方法？请列举" class="headerlink" title="排序都有哪几种方法？请列举"></a>排序都有哪几种方法？请列举</h3><p>插入排序</p>
<ul>
<li>直接插入排序</li>
<li>希尔排序<br>选择排序</li>
<li>直接选择排序</li>
<li>堆排序<br>交换排序</li>
<li>冒泡排序</li>
<li>快速排序<br>并归排序</li>
</ul>
<h3 id="说出一些常用的类，包，接口，请各举5个"><a href="#说出一些常用的类，包，接口，请各举5个" class="headerlink" title="说出一些常用的类，包，接口，请各举5个"></a>说出一些常用的类，包，接口，请各举5个</h3><ul>
<li>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer常用的包：java.lang java.awt java.io java.util java.sql</li>
<li>常用的接口：Remote List Map Document NodeList</li>
</ul>
<h3 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h3><p>理论上 Java 因为有垃圾回收机制（ GC）不会存在内存泄露问 题（ 这也是 Java 被广泛使用于服务器端编程的一个重要 原因 ）；然而在实际开发中 ，可能会存在无用但可达的对象，这些对象不能被 GC 回收 ，因此也会导致内存 泄露的发生 。</p>
<h3 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a><strong>如何实现对象克隆？</strong></h3><p><strong>有两种方式：</strong></p>
<p>1). 实现 Cloneable 接口并重写 Object 类中的 clone()方法；<br>2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</p>
<h3 id="一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><p>可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p>
<h2 id="集合、泛型"><a href="#集合、泛型" class="headerlink" title="集合、泛型"></a>集合、泛型</h2><h3 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a>ArrayList和linkedList的区别</h3><p>Array(数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。<br>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,(因为删除数据以后, 需要把后面所有的数据前移)</p>
<p><strong>缺点:</strong> 数组初始化必须指定初始化的长度, 否则报错</p>
<ul>
<li>List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</li>
<li>List有两个重要的实现类：ArrayList和LinkedList<br>ArrayList: 可以看作是能够自动增长容量的数组</li>
<li>ArrayList的toArray方法返回一个数组</li>
<li>ArrayList的asList方法返回一个列表</li>
<li>ArrayList底层的实现是Array, 数组扩容实现</li>
<li><strong>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</strong>【相对而言】</li>
</ul>
<h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><blockquote>
<p>这个部分的引申部分可以很多，抓到什么部分就拐进去多讲点，但是自己不要硬撑，讲慢点过过脑子</p>
</blockquote>
<p><strong>1、两者父类不同</strong><br>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现<br>了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。<br><strong>2、对外提供的接口不同</strong><br>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的<br>value的枚举。<br>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，<br>contansValue() 就只是调用了一下contains() 方法。<br><strong>3、对null的支持不同</strong></p>
<p> Hashtable：key和value都不能为null。</p>
<p>HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key<br>值对应的value为null。</p>
<p><strong>4、安全性不同</strong><br>HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己<br>处理多线程的安全问题。<br>Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。<br>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。<br>ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为<br>ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。<br><strong>5、初始容量大小和每次扩充容量大小不同</strong></p>
<p><strong>6、计算hash值的方法不同</strong></p>
<h3 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h3><ul>
<li>Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；</li>
<li>Collections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</li>
</ul>
<h3 id="简单的说一下List，Set-Map三者的区别"><a href="#简单的说一下List，Set-Map三者的区别" class="headerlink" title="简单的说一下List，Set,Map三者的区别"></a>简单的说一下List，Set,Map三者的区别</h3><ul>
<li><p><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象<br><strong>最常用实现类</strong><br><code>ArrayList：</code>基于动态数组实现，随机访问元素快，增删元素慢。<br><code>LinkedList：</code>基于双向链表实现，适合频繁插入和删除操作，特别是操作列表两端元素时，但随机访问元素慢。<br><code>Vector：</code>类似于 ArrayList ，但线程安全</p>
</li>
<li><p><strong>Set(注重独一无二的性质):</strong>不允许重复的集合。不会有多个元素引用相同的对象。<br><strong>常见实现类</strong><br><code>HashSet：</code>基于哈希表实现，提供快速的插入、删除和查找操作，但不保证元素的顺序。<br><code>LinkedHashSet：</code>是 HashSet 的有序版本，维护插入元素的顺序。<br><code>TreeSet：</code>基于红黑树实现，存储元素时会自动排序，适合需要排序操作的场景。</p>
</li>
<li><p><strong>Map(用Key来搜索的专一):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。<br><strong>常见实现类</strong><br><code>HashMap：</code>基于哈希表实现，提供快速的插入、删除和查找操作，但不保证键值对的顺序。<br><code>LinkedHashMap：</code>是 HashMap 的有序版本，维护键值对的插入顺序。<br><code>TreeMap：</code>基于红黑树实现，存储键值对时会自动按照键的自然顺序或自定义顺序进行排序。<br><code>Hashtable：</code>类似于 HashMap，但线程安全。</p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Java中异常分为哪两种？"><a href="#Java中异常分为哪两种？" class="headerlink" title="Java中异常分为哪两种？"></a>Java中异常分为哪两种？</h3><p>可以分为编译时异常和运行时异常这两种大类</p>
<h3 id="异常的处理机制有几种"><a href="#异常的处理机制有几种" class="headerlink" title="异常的处理机制有几种"></a>异常的处理机制有几种</h3><p>异常捕捉：try…catch…finally，异常抛出：throws。</p>
<blockquote>
<p>他们一个在代码块中，排除特定部分，一个在方法体处抛出</p>
</blockquote>
<ul>
<li><h3 id="关于异常而言try-catch-fifinally，try里有return，finally还执行么？"><a href="#关于异常而言try-catch-fifinally，try里有return，finally还执行么？" class="headerlink" title="关于异常而言try catch fifinally，try里有return，finally还执行么？"></a>关于异常而言try catch fifinally，try里有return，finally还执行么？</h3><p><strong>执行</strong>，并且finally的执行早于try里面的return<br><strong>结论：</strong><br>1、不管有木有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，<br>返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p>
</li>
</ul>
<h3 id="Thow与thorws区别"><a href="#Thow与thorws区别" class="headerlink" title="Thow与thorws区别"></a>Thow与thorws区别</h3><p><strong>位置不同</strong></p>
<ol>
<li>throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的<br>是异常对象。</li>
</ol>
<p><strong>功能不同：</strong></p>
<ol>
<li>throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方<br> 式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并<br> 将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语<br> 句，因为执行不到。</li>
<li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，<br> 执行 throw 则一定抛出了某种异常对象。</li>
<li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异<br> 常，真正的处理异常由函数的上层调用处理。</li>
</ol>
<h3 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别"></a>error和exception有什么区别</h3><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的况 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</p>
<h2 id="IO-amp-amp-NIO"><a href="#IO-amp-amp-NIO" class="headerlink" title="IO&amp;&amp; NIO"></a>IO&amp;&amp; NIO</h2><h3 id="java中的IO流"><a href="#java中的IO流" class="headerlink" title="java中的IO流"></a>java中的IO流</h3><p><strong>Java 中 IO 流分为几种</strong><br><strong>Java 中 IO 流？</strong></p>
<ol>
<li>按照流的向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ol>
<p><strong>典型基类</strong></p>
<ol>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ol>
<h3 id="java中的IO和NIO的区别"><a href="#java中的IO和NIO的区别" class="headerlink" title="java中的IO和NIO的区别"></a>java中的IO和NIO的区别</h3><ol>
<li>Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的</li>
<li>Java IO的各种流是阻塞的，Java NIO的非阻塞模式</li>
<li>Java NIO的选择器允许一个单独的线程来监视多个输入通道</li>
</ol>
<h3 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h3><p>以字节为单位输入输出数据，字节流按照8位传输<br>以字符为单位输入输出数据，字符流按照16位传输</p>
<h3 id="javaNIO"><a href="#javaNIO" class="headerlink" title="javaNIO"></a>javaNIO</h3><p>NIO 主要有三大核心部分： Channel(通道)， Buffer(缓冲区), Selector。传统 IO 基于字节流和字符流进行操作， 而 NIO 基于 Channel 和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 NIO 和传统 IO 之间第一个最大的区别是， IO 是面向流的， NIO 是面向缓冲区的。</p>
<ul>
<li><h3 id="NIO的缓冲区"><a href="#NIO的缓冲区" class="headerlink" title="NIO的缓冲区"></a>NIO的缓冲区</h3><p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据， 需要先将它缓存到一个缓冲区。 NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote>
<p>Q：除开使用new来创建一个对象，还可以通过那些方法来创建一个对象</p>
<p>A：可以使用反射机制来创建一个对象</p>
</blockquote>
<p>通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低</p>
<h3 id="java反射的作用"><a href="#java反射的作用" class="headerlink" title="java反射的作用"></a>java反射的作用</h3><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意个对象，都能够调用其任意一个方法，在java中，只要给定一个类的名字，就可以通过反射机制来获得类的所有信息</p>
<h4 id="反射的实现方式"><a href="#反射的实现方式" class="headerlink" title="反射的实现方式"></a>反射的实现方式</h4><p>可以通过四种方式来进行获得一个反射对象</p>
<p>1）Class.forName(“类的路径”)；</p>
<p>2）类名.class</p>
<p>3）对象名.getClass()</p>
<p>4）基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象</p>
<h4 id="可以实现java反射的类为："><a href="#可以实现java反射的类为：" class="headerlink" title="可以实现java反射的类为："></a>可以实现java反射的类为：</h4><p>1）Class：表示正在运行的Java应用程序中的类和接口</p>
<p>注意： 所有获取对象的信息都需要Class类来实现。</p>
<p>2）Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p>
<p>3）Constructor：提供关于类的单个构造方法的信息以及它的访问权限</p>
<p>4）Method：提供类或接口中某个方法的信息</p>
<h4 id="如何通过反射机制来创建对象实例呢"><a href="#如何通过反射机制来创建对象实例呢" class="headerlink" title="如何通过反射机制来创建对象实例呢"></a>如何通过反射机制来创建对象实例呢</h4><p><strong>Class 对象的newInstance()</strong></p>
<p>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求<br>该 Class 对象对应的类有默认的空构造器。</p>
<p><strong>调用 Constructor 对象的 newInstance()</strong></p>
<p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()<br>方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="什么是Java序列化，如何实现Java序列化？"><a href="#什么是Java序列化，如何实现Java序列化？" class="headerlink" title="什么是Java序列化，如何实现Java序列化？"></a>什么是Java序列化，如何实现Java序列化？</h3><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。</p>
<p><strong>实现序列化的步骤</strong></p>
<ul>
<li><strong>标记可序列化</strong>：让类实现<code>Serializable</code>接口</li>
<li><strong>序列化对象</strong>：使用<code>ObjectOutputStream</code></li>
<li><strong>反序列化</strong>：使用<code>ObjectInputStream</code></li>
</ul>
<p>Java序列化是指将Java对象转换为字节流的过程，以便存储或网络传输。其本质是把对象的内存状态转化为可重建的二进制格式，就像把立体模型拆解成平面图纸。</p>
<h3 id="保存-持久化-对象及其状态到内存或者磁盘"><a href="#保存-持久化-对象及其状态到内存或者磁盘" class="headerlink" title="保存(持久化)对象及其状态到内存或者磁盘"></a>保存(持久化)对象及其状态到内存或者磁盘</h3><p>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。 但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。</p>
<h3 id="序列化对象以字节数组保持-静态成员不保存"><a href="#序列化对象以字节数组保持-静态成员不保存" class="headerlink" title="序列化对象以字节数组保持-静态成员不保存"></a>序列化对象以字节数组保持-静态成员不保存</h3><p>使用 Java 对象序列化， 在保存对象时，会把其状态保存为一组字节，在未来， 再将这些字节组装成对象。必须注意地是， 对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。</p>
<h3 id="序列化用户远程对象传输"><a href="#序列化用户远程对象传输" class="headerlink" title="序列化用户远程对象传输"></a>序列化用户远程对象传输</h3><p>除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。 Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><blockquote>
<p>注解是什么，Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。 Annatation(注解)是一个接口，程<br>序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该 Annotation 对象来获取注解中的元数据信息。</p>
</blockquote>
<h3 id="Java中的四种标准元注解（用于注解其他注解的注解）包括："><a href="#Java中的四种标准元注解（用于注解其他注解的注解）包括：" class="headerlink" title="Java中的四种标准元注解（用于注解其他注解的注解）包括："></a>Java中的四种标准元注解（用于注解其他注解的注解）包括：</h3><ol>
<li><strong>@Target</strong> - 指定注解可以应用的目标元素类型（如类、方法、字段等）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD) // 只能用在方法上</span><br><span class="line">public @interface MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>@Retention</strong> - 定义注解的保留策略（源码/编译时/运行时）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME) // 运行时保留</span><br><span class="line">public @interface MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>@Documented</strong> - 标记注解是否包含在Javadoc中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Documented // 生成文档时会包含此注解</span><br><span class="line">public @interface MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>@Inherited</strong> - 允许子类继承父类的注解</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inherited // 子类会自动继承此注解</span><br><span class="line">public @interface MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这些元注解都位于<code>java.lang.annotation</code>包中，是定义自定义注解的基础构件。</p>
<h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><ul>
<li>继承Thread类；</li>
<li>实现Runnable接口；</li>
<li>实现Callable接口通过FutureTask包装器来创建Thread线程；</li>
<li>使用ExecutorService<code>伊克斯科一欧的</code>、Callable、Future实现有返回结果的多线程（也就是使用了ExecutorService来管理前面的三种方式）。</li>
<li>基于线程池的方式</li>
</ul>
<h3 id="如何停止一个正在运行的线程"><a href="#如何停止一个正在运行的线程" class="headerlink" title="如何停止一个正在运行的线程"></a><strong>如何停止一个正在运行的线程</strong></h3><ol>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li>
<li>使用interrupt方法中断线程。</li>
</ol>
<h3 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h3><p>线程相关的基本方法有 wait（线程等待）， notify（线程唤醒）， notifyAll（线程全唤醒）， sleep（线程睡眠）， join（等待线程终止）， yield（线程让步） 等。</p>
<p><strong>线程等待（wait）：</strong>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后， 会释放对象的锁。因此， wait 方法一般用在同步方法或同步代码块中。</p>
<p><strong>线程睡眠（sleep）</strong>：sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态</p>
<p><strong>线程让步（yield）</strong>：</p>
<p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片， 但这又不是绝对的，有的操作系统对线程优先级并不敏感。</p>
<p><strong>等待线程终止（join）:</strong>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p>
<p><strong>线程唤醒（notify）</strong>:Object 类中的 notify() 方法， 唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待， 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p>
<blockquote>
<p>说人话理解版本：</p>
<p><strong>1. wait()、notify()、notifyAll() —— 餐厅等位系统</strong></p>
<ul>
<li><strong>wait()</strong>：就像在餐厅取号后去休息区等待，把座位（锁）让给别人</li>
<li><strong>notify()</strong>：服务员叫一个号（随机唤醒一个等待线程）</li>
<li><strong>notifyAll()</strong>：服务员大喊”现在有空位了”（唤醒所有等待线程）</li>
</ul>
<p>关键点：必须先在收银台登记（synchronized块内）才能使用这些方法</p>
<p><strong>2. sleep() —— 手机定时勿扰模式</strong></p>
<ul>
<li>设定闹钟睡1小时（Thread.sleep(1000)）</li>
<li>睡着时手机还在你手里（不释放锁）</li>
<li>闹钟响了才会醒（时间到自动恢复）</li>
</ul>
<p><strong>3. yield() —— 公交车让座</strong></p>
<ul>
<li>主动站起来说”您坐这儿吧”（让出CPU）</li>
<li>实际是否有人来坐不确定（JVM决定是否切换线程）</li>
<li>让座后自己还站在车上（线程仍处于可运行状态）</li>
</ul>
<p><strong>4. join() —— 等同事下班拼车</strong></p>
<ul>
<li>给同事发微信”下班叫我”（t.join()）</li>
<li>一直等到同事忙完（目标线程终止）</li>
<li>最多等30分钟，不来我就自己走（join(1800000)）</li>
</ul>
<p><strong>5. 对比总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>类比场景</th>
<th>关键特点</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait()</td>
<td>餐厅等位</td>
<td>让出座位+等待通知</td>
<td>必须提前拿到号牌(synchronized)</td>
</tr>
<tr>
<td>sleep()</td>
<td>定时午睡</td>
<td>睡着但手机不借人</td>
<td>别睡太久影响效率</td>
</tr>
<tr>
<td>yield()</td>
<td>公交车让座</td>
<td>客气一下未必真让</td>
<td>不能指望一定有效</td>
</tr>
<tr>
<td>join()</td>
<td>等同事一起走</td>
<td>死等或定时等待</td>
<td>别让同事等太久（避免无限阻塞）</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<h3 id="sleep-和wait-有什么异同点"><a href="#sleep-和wait-有什么异同点" class="headerlink" title="sleep()和wait()有什么异同点"></a>sleep()和wait()有什么异同点</h3><blockquote>
<p>说人话就是，sleep()是让线程睡一会儿，不释放锁；wait()是让线程等着，会释放锁，等别人叫醒它。一个是小憩一下，到点自然醒，一个是睡美人，得有人亲一下</p>
</blockquote>
<ol>
<li>sleep() 是 Thread 类的静态本地方法；wait() 是Object类的成员本地方法；</li>
<li>JDK1.8 sleep() wait() 均需要捕获 InterruptedException 异常；</li>
<li>sleep() 方法可以在任何地方使用；wait() 方法则只能在同步方法或同步代码块中使用；</li>
<li>sleep() 会休眠当前线程指定时间，释放 CPU 资源，不释放对象锁，休眠时间到自动苏醒继续执行；wait() 方法放弃持有的对象锁，进入等待队列，当该对象被调用 notify() / notifyAll() 方法后才有机会竞争获取对象锁，进入运行状态。</li>
</ol>
<h3 id="sleep-与yield-的区别？"><a href="#sleep-与yield-的区别？" class="headerlink" title="sleep()与yield()的区别？"></a><strong>sleep()与yield()的区别？</strong></h3><blockquote>
<p>sleep()是强制让线程睡指定时间；yield()是礼貌性让出CPU，但可能马上又被调度回来。</p>
</blockquote>
<ol>
<li>sleep() 方法给其他线程运行机会时不考虑线程的优先级；yield() 方法只会给相同优先级或更高优先级的线程运行的机会；</li>
<li>sleep() 方法声明抛出 InterruptedException；yield() 方法没有声明抛出异常；</li>
<li>线程执行 sleep() 方法后进入超时等待状态；线程执行 yield() 方法转入就绪状态，可能马上又得得到执行；</li>
<li>sleep() 方法需要指定时间参数；yield() 方法出让 CPU 的执行权时间由 JVM 控制。</li>
</ol>
<h3 id="Theard类中的Yield方法有什么作用？"><a href="#Theard类中的Yield方法有什么作用？" class="headerlink" title="Theard类中的Yield方法有什么作用？"></a>Theard类中的Yield方法有什么作用？</h3><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h3 id="sleep-与join-的区别？"><a href="#sleep-与join-的区别？" class="headerlink" title="sleep()与join()的区别？"></a><strong>sleep()与join()的区别？</strong></h3><blockquote>
<p>sleep()是单纯睡觉不释放锁；join()是等另一个线程干完活再继续，期间会释放锁。</p>
</blockquote>
<ol>
<li>JDK1.8 sleep() join() 均需要捕获 InterruptedException 异常；</li>
<li>sleep()是Thread的静态本地方法，join()是Thread的普通方法；</li>
<li>sleep()不会释放锁资源，join()底层是wait方法，会释放锁。</li>
</ol>
<h3 id="notify-和notifyAll有什么区别？"><a href="#notify-和notifyAll有什么区别？" class="headerlink" title="notify()和notifyAll有什么区别？"></a>notify()和notifyAll有什么区别？</h3><blockquote>
<p>这两个都是宿管，一个叫醒全部人，一个只叫醒一个，所以全部叫醒不会抢饭，但是只叫醒一个大概率会抢饭</p>
</blockquote>
<ul>
<li>notify可能会导致死锁，而notifyAll则不会</li>
<li>任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 的代码使用notifyall,可以唤醒</li>
<li>所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个</li>
<li>wait() 应配合while循环使用，不应使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续wait()直至条件满足再往下执行。</li>
<li>notify() 是对notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是 WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中.</li>
</ul>
<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>线程安全就是说多线程访问同一代码，不会产生不确定的结果。</p>
<p>在多线程环境中，当各线程不共享数据的时候，即都是私有（private）成员，那么一定是线程安全的。但这种情况并不多见，在多数情况下需要共享数据，这时就需要进行适当的同步控制了。</p>
<p>线程安全一般都涉及到synchronized， 就是一段代码同时只能有一个线程来操作 不然中间过程可能会产生不可预知的结果。</p>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p><strong>引申问题</strong></p>
<ul>
<li><p><strong>什么是线程安全？Vector是一个线程安全类吗？</strong></p>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似 的ArrayList不是线程安全的。</p>
</li>
</ul>
<h3 id="什么是线程池，线程池的优点，线程池的工作流程"><a href="#什么是线程池，线程池的优点，线程池的工作流程" class="headerlink" title="什么是线程池，线程池的优点，线程池的工作流程"></a>什么是线程池，线程池的优点，线程池的工作流程</h3><p><strong>什么是线程池</strong><br>线程池是一种基于池化技术的线程使用模式。它预先创建一定数量的线程，将这些线程放在一个池子中，当有任务需要执行时，从池中取出空闲线程来执行任务，任务执行完毕后，线程不会被销毁，而是重新放回池中等待下一个任务。</p>
<p><strong>为什么需要线程池</strong></p>
<p><strong>降低资源消耗：</strong>通过重复利用已创建的线程，减少线程创建和销毁造成的消耗<br><strong>提高响应速度：</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行<br><strong>提高线程的可管理性：</strong>统一管理线程，避免系统中线程数量失控<br><strong>提供更多功能：</strong>线程池具备可拓展性，提供定时执行、定期执行等功能</p>
<p><strong>线程池的核心优势</strong></p>
<p><strong>资源控制：</strong>限制并发线程数，避免系统资源耗尽<br><strong>任务管理：</strong>提供任务队列，支持任务的缓存和调度<br><strong>监控统计：</strong>提供线程池运行状态的监控和统计信息<br><strong>灵活配置：</strong>支持多种配置参数，适应不同的业务场景</p>
<p><strong>线程池的工作流程可以用以下步骤描述：</strong></p>
<p><strong>任务提交：</strong>客户端提交任务到线程池<br><strong>核心线程检查：</strong>如果运行线程数少于核心线程数，创建新线程执行任务<br><strong>队列缓存：</strong>如果核心线程都在忙碌，任务被放入工作队列<br><strong>扩容处理：</strong>如果队列满了且线程数未达到最大值，创建新的非核心线程<br><strong>拒绝策略：</strong>如果队列满了且线程数已达最大值，执行拒绝策略</p>
<p><strong>核心线程 vs 非核心线程</strong></p>
<p><strong>核心线程（Core Threads）：</strong>线程池中始终保持活跃的线程，即使它们处于空闲状态<br><strong>非核心线程（Non-Core Threads）：</strong>当核心线程不足以处理任务时创建的额外线程，空闲时会被回收</p>
<p><strong>任务队列的作用</strong><br>任务队列用于保存等待执行的任务，它是连接任务提交和任务执行的桥梁。不同类型的队列会影响线程池的行为：</p>
<p><strong>有界队列：</strong>防止内存溢出，但可能导致任务被拒绝<br><strong>无界队列：</strong>可以接受大量任务，但可能导致内存问题<br><strong>同步队列：</strong>不存储任务，直接传递给线程</p>
<p><strong>线程池的生命周期</strong></p>
<p>线程池具有以下几种状态：</p>
<p><strong>RUNNING：</strong>接受新任务，处理队列中的任务<br><strong>SHUTDOWN：</strong>不接受新任务，但会处理队列中的任务<br><strong>STOP：</strong>不接受新任务，不处理队列中的任务，中断正在执行的任务<br><strong>TIDYING：</strong>所有任务已终止，workerCount为0<br><strong>TERMINATED：</strong>terminated()方法执行完成</p>
<blockquote>
<p>通常我们常说的是，<code>新建状态</code>，<code>就绪状态</code>，<code>运行状态</code>，<code>阻塞状态</code>，<code>线程死亡</code></p>
<p>其中，阻塞状态还有三个状态</p>
<p><strong>等待阻塞</strong>（o.wait-&gt;等待对列） ：</p>
<p>运行(running)的线程执行 o.wait()方法， JVM 会把该线程放入等待队列(waitting queue)中。</p>
<p><strong>同步阻塞</strong>(lock-&gt;锁池)</p>
<p>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。</p>
<p><strong>其他阻塞</strong>(sleep/join)</p>
<p>运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、 join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
</blockquote>
<h3 id="终止线程的四种方式"><a href="#终止线程的四种方式" class="headerlink" title="终止线程的四种方式"></a>终止线程的四种方式</h3><ul>
<li><p><strong>正常运行结束</strong></p>
<p>线程自动结束的方式，最健康了</p>
</li>
<li><p><strong>使用退出标志退出线程</strong></p>
<p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。</p>
</li>
<li><p><strong>interrupt方法结束线程</strong></p>
<p>使用 interrupt()方法来中断线程有两种情况：</p>
<p>1.线程处于阻塞状态： 如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。 通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。</p>
<p>2.线程未处于阻塞状态： 使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p>
</li>
<li><p><strong>stop方法终止线程（线程不安全）</strong></p>
</li>
</ul>
<h3 id="实现线程同步的三个方式"><a href="#实现线程同步的三个方式" class="headerlink" title="实现线程同步的三个方式"></a>实现线程同步的三个方式</h3><h4 id="采用同步代码块"><a href="#采用同步代码块" class="headerlink" title="采用同步代码块"></a>采用同步代码块</h4><p><strong>特点</strong>：</p>
<ul>
<li>只锁定代码块而不是整个方法</li>
<li>需要显式指定锁对象</li>
<li>锁对象可以是任意对象，但通常使用专门的对象或this</li>
<li>进入同步块前必须获得锁，否则线程会阻塞</li>
</ul>
<h4 id="采用同步方法"><a href="#采用同步方法" class="headerlink" title="采用同步方法"></a>采用同步方法</h4><p><strong>特点</strong>：</p>
<ul>
<li>整个方法都是同步的</li>
<li>对于实例方法，锁是当前实例对象(this)</li>
<li>对于静态方法，锁是当前类的Class对象</li>
<li>实现简单，但粒度较粗可能影响性能</li>
</ul>
<h4 id="采用-Lock-锁对象实例"><a href="#采用-Lock-锁对象实例" class="headerlink" title="采用 Lock 锁对象实例"></a>采用 Lock 锁对象实例</h4><p><strong>特点</strong>：</p>
<ul>
<li>比synchronized更灵活，可以尝试获取锁、定时获取锁等</li>
<li>需要显式地获取和释放锁</li>
<li>必须在finally块中释放锁以防止死锁</li>
<li>提供了更多高级功能如公平锁、读写锁等</li>
<li>性能通常优于synchronized</li>
</ul>
<h3 id="start-和run-的区别"><a href="#start-和run-的区别" class="headerlink" title="start()和run()的区别"></a>start()和run()的区别</h3><blockquote>
<p>start中包含了run的方法部分，这一点请一定要描述出来</p>
</blockquote>
<ol>
<li><p>start（） 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</p>
</li>
<li><p>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</p>
</li>
<li><p>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p>
</li>
</ol>
<h3 id="java后台线程"><a href="#java后台线程" class="headerlink" title="java后台线程"></a>java后台线程</h3><p>后台线程也称为守护线程 (比如JVM处理垃圾回收 使用的就是后台线程)，  我们创建的线程一般用于处理我们自己的某些任务，而后台线程主要用于一些公共的任务以提供服务。</p>
<p>我们创建的线程可以在start()启动前使用  thread.setDaemon(true); 来将其设置为后台线程，使用isDaemon()来判断线程是否为后台线程。</p>
<p><del>要是你说什么是非后台线程，这纯属废话，除了后台线程外其他线程都属于非后台线程</del></p>
<h3 id="常用线程池（请说英文—中文）"><a href="#常用线程池（请说英文—中文）" class="headerlink" title="常用线程池（请说英文—中文）"></a>常用线程池（请说英文—中文）</h3><h4 id="FixedThreadPool（固定大小线程池）"><a href="#FixedThreadPool（固定大小线程池）" class="headerlink" title="FixedThreadPool（固定大小线程池）"></a>FixedThreadPool（固定大小线程池）</h4><p><strong>特点</strong>：</p>
<ul>
<li>核心线程数和最大线程数相等</li>
<li>使用无界队列LinkedBlockingQueue</li>
<li>适合负载比较重的服务器</li>
</ul>
<p><strong>使用场景</strong>：已知并发量，需要控制线程数的场景</p>
<h4 id="CachedThreadPool（缓存线程池）"><a href="#CachedThreadPool（缓存线程池）" class="headerlink" title="CachedThreadPool（缓存线程池）"></a>CachedThreadPool（缓存线程池）</h4><p><strong>特点</strong>：</p>
<ul>
<li>核心线程数为0，最大线程数为Integer.MAX_VALUE</li>
<li>使用SynchronousQueue</li>
<li>线程空闲60秒后被回收</li>
<li>适合执行很多短期异步任务</li>
</ul>
<p><strong>使用场景</strong>：任务量变化较大，任务执行时间较短的场景</p>
<h4 id="SingleThreadExecutor（单线程池）"><a href="#SingleThreadExecutor（单线程池）" class="headerlink" title="SingleThreadExecutor（单线程池）"></a>SingleThreadExecutor（单线程池）</h4><p><strong>特点</strong>：</p>
<ul>
<li>只有一个线程的线程池</li>
<li>保证任务按提交顺序执行</li>
<li>适合需要保证顺序执行的场景</li>
</ul>
<h4 id="ScheduledThreadPool（定时任务线程池）"><a href="#ScheduledThreadPool（定时任务线程池）" class="headerlink" title="ScheduledThreadPool（定时任务线程池）"></a>ScheduledThreadPool（定时任务线程池）</h4><p><strong>特点</strong>：</p>
<ul>
<li>支持定时和周期性任务执行</li>
<li>使用DelayedWorkQueue</li>
<li>适合需要定时执行任务的场景</li>
</ul>
<h3 id="java中线程池框架"><a href="#java中线程池框架" class="headerlink" title="java中线程池框架"></a>java中线程池框架</h3><p><strong>Executor框架概述</strong><br>Java的Executor框架为线程池提供了统一的接口和实现。该框架的核心组件包括：</p>
<ul>
<li>Executor：最基础的接口，只定义了execute方法</li>
<li>ExecutorService：扩展了Executor，提供了更丰富的线程池管理功能</li>
<li>ThreadPoolExecutor：ExecutorService的具体实现类</li>
<li>Executors：提供静态工厂方法创建各种类型的线程池</li>
</ul>
<p><strong>ExecutorService接口</strong></p>
<ul>
<li>ExecutorService提供了线程池的核心功能：</li>
</ul>
<p><strong>ThreadPoolExecutor类详解</strong></p>
<ul>
<li>ThreadPoolExecutor是线程池的核心实现类，提供了完整的线程池功能。它的构造函数参数决定了线程池的行为特征。</li>
</ul>
<p><strong>Executors工具类</strong></p>
<ul>
<li>Executors类提供了创建常用线程池的静态方法，简化了线程池的创建过程。但在生产环境中，建议直接使用ThreadPoolExecutor构造函数，以获得更好的控制力</li>
</ul>
<h3 id="线程池七大核心参数"><a href="#线程池七大核心参数" class="headerlink" title="线程池七大核心参数"></a>线程池七大核心参数</h3><blockquote>
<p>在Java开发中，线程池是一个常用的技术。创建线程池时需要指定七个参数，分别是核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、空闲线程存活时间（keepAliveTime）、时间单位（unit）、工作队列（workQueue）、线程工厂（threadFactory）和拒绝策略（handler）。</p>
</blockquote>
<p><strong>核心线程数（corePoolSize）</strong></p>
<p>核心线程数是线程池中维护的最小线程数量，即使这些线程处于空闲状态，它们也不会被销毁，除非设置了<em>allowCoreThreadTimeOut</em>。当任务提交到线程池时，如果当前线程数小于核心线程数，则会创建一个新线程来处理任务。</p>
<p><strong>最大线程数（maximumPoolSize）</strong></p>
<p>最大线程数是线程池允许创建的最大线程数量。当核心线程数已满且工作队列也已满时，线程池会创建新线程来处理任务，但不会超过最大线程数。</p>
<p><strong>空闲线程存活时间（keepAliveTime）</strong></p>
<p>空闲线程存活时间是指当线程处于空闲状态且当前线程数大于核心线程数时，线程在指定时间后会被销毁。这个时间由<em>keepAliveTime</em>参数设定。</p>
<p><strong>时间单位（unit）</strong></p>
<p>时间单位是指<em>keepAliveTime</em>的计量单位，可以是纳秒、微秒、毫秒、秒、分钟、小时或天。</p>
<p><strong>工作队列（workQueue）</strong></p>
<p>工作队列用于存放待执行的任务。Java提供了四种工作队列：</p>
<ul>
<li><strong>ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按FIFO排序。</li>
<li><strong>LinkedBlockingQueue</strong>：基于链表的无界阻塞队列，按FIFO排序。</li>
<li><strong>SynchronousQueue</strong>：不缓存任务的阻塞队列，生产者放入任务必须等待消费者取出任务。</li>
<li><strong>PriorityBlockingQueue</strong>：具有优先级的无界阻塞队列，优先级通过Comparator实现。</li>
</ul>
<p><strong>线程工厂（threadFactory）</strong></p>
<p>线程工厂用于创建新线程，可以设定线程名、是否为守护线程等。默认的线程工厂会为每个线程池创建一个新的线程组，并为每个线程分配一个唯一的名称。</p>
<p><strong>拒绝策略（handler）</strong></p>
<p>当工作队列已满且线程池中的线程数量达到最大限制时，新任务会被拒绝。Java提供了四种拒绝策略：</p>
<ul>
<li><strong>CallerRunsPolicy</strong>：在调用者线程中直接执行被拒绝的任务。</li>
<li><strong>AbortPolicy</strong>：丢弃任务并抛出<em>RejectedExecutionException</em>异常。</li>
<li><strong>DiscardPolicy</strong>：丢弃任务但不抛出异常。</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃队列中最早的任务，然后尝试重新提交被拒绝的任务。</li>
</ul>
<h3 id="工作队列类型详解"><a href="#工作队列类型详解" class="headerlink" title="工作队列类型详解"></a>工作队列类型详解</h3><blockquote>
<p>工作队列主要有ArrayBlockingQueue（有界队列），LinkedBlockingQueue（无界队列），SynchronousQueue（同步队列），PriorityBlockingQueue（优先级队列），DelayedWorkQueue（延迟队列）</p>
</blockquote>
<p>有界，无界，同步队列，优先，延迟，拒绝策略——小口诀</p>
<h4 id="ArrayBlockingQueue（有界队列）"><a href="#ArrayBlockingQueue（有界队列）" class="headerlink" title="ArrayBlockingQueue（有界队列）"></a>ArrayBlockingQueue（有界队列）</h4><p>基于数组实现的有界阻塞队列，按FIFO原则对任务进行排序。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>队列容量固定，防止内存溢出</li>
<li>当队列满时，新任务会触发拒绝策略</li>
<li>适合对内存使用有严格要求的场景</li>
</ul>
<h4 id="LinkedBlockingQueue（无界队列）"><a href="#LinkedBlockingQueue（无界队列）" class="headerlink" title="LinkedBlockingQueue（无界队列）"></a>LinkedBlockingQueue（无界队列）</h4><p>基于链表实现的阻塞队列，理论上可以无限存储任务。</p>
<p><strong>特点：</strong></p>
<ul>
<li>默认容量为Integer.MAX_VALUE，实际上是无界的</li>
<li>maximumPoolSize参数失效</li>
<li>可能导致内存溢出</li>
<li>适合任务量不可预测的场景</li>
</ul>
<h4 id="SynchronousQueue（同步队列）"><a href="#SynchronousQueue（同步队列）" class="headerlink" title="SynchronousQueue（同步队列）"></a>SynchronousQueue（同步队列）</h4><p>一个不存储元素的阻塞队列，每个插入操作必须等待对应的删除操作。</p>
<p><strong>特点：</strong></p>
<ul>
<li>没有容量，不存储任务</li>
<li>每个任务都会直接传递给线程</li>
<li>适合任务量变化较大的场景</li>
<li>CachedThreadPool使用此队列</li>
</ul>
<h4 id="PriorityBlockingQueue（优先级队列）"><a href="#PriorityBlockingQueue（优先级队列）" class="headerlink" title="PriorityBlockingQueue（优先级队列）"></a>PriorityBlockingQueue（优先级队列）</h4><p>基于优先级的无界阻塞队列，支持任务按优先级执行。</p>
<p><strong>特点：</strong></p>
<ul>
<li>任务必须实现Comparable接口或提供Comparator</li>
<li>高优先级任务会优先执行</li>
<li>适合有明确优先级要求的场景</li>
</ul>
<h4 id="DelayedWorkQueue（延迟队列）"><a href="#DelayedWorkQueue（延迟队列）" class="headerlink" title="DelayedWorkQueue（延迟队列）"></a>DelayedWorkQueue（延迟队列）</h4><ul>
<li>ScheduledThreadPoolExecutor内部使用的延迟队列，支持定时任务。</li>
</ul>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><h4 id="AbortPolicy（抛出异常）"><a href="#AbortPolicy（抛出异常）" class="headerlink" title="AbortPolicy（抛出异常）"></a>AbortPolicy（抛出异常）</h4><p>默认的拒绝策略，直接抛出RejectedExecutionException异常。</p>
<h4 id="CallerRunsPolicy（调用者执行）"><a href="#CallerRunsPolicy（调用者执行）" class="headerlink" title="CallerRunsPolicy（调用者执行）"></a>CallerRunsPolicy（调用者执行）</h4><p>由调用线程执行被拒绝的任务，这是一种负反馈机制。</p>
<h4 id="DiscardPolicy（丢弃任务）"><a href="#DiscardPolicy（丢弃任务）" class="headerlink" title="DiscardPolicy（丢弃任务）"></a>DiscardPolicy（丢弃任务）</h4><p>静默丢弃被拒绝的任务，不做任何处理。</p>
<h4 id="DiscardOldestPolicy（丢弃最老任务）"><a href="#DiscardOldestPolicy（丢弃最老任务）" class="headerlink" title="DiscardOldestPolicy（丢弃最老任务）"></a>DiscardOldestPolicy（丢弃最老任务）</h4><p>丢弃队列中最老的任务，然后重新提交当前任务。</p>
<h4 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h4><p>自行定义的，可以根据实际业务需求的拒绝策略</p>
<h3 id="如何选择合适的线程池大小"><a href="#如何选择合适的线程池大小" class="headerlink" title="如何选择合适的线程池大小"></a>如何选择合适的线程池大小</h3><blockquote>
<p>这个题目相对灵活的多，但是一般性遵照某些基本原则</p>
</blockquote>
<p><strong>基本原则</strong>：</p>
<ul>
<li>线程数过少：无法充分利用系统资源，吞吐量低</li>
<li>线程数过多：增加上下文切换开销，可能导致系统资源耗尽</li>
</ul>
<h3 id="线程池调优技巧"><a href="#线程池调优技巧" class="headerlink" title="线程池调优技巧"></a>线程池调优技巧</h3><ol>
<li><p><strong>动态调整线程池参数</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时调整核心线程数</span></span><br><span class="line">executor.setCorePoolSize(newCoreSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时调整最大线程数</span></span><br><span class="line">executor.setMaximumPoolSize(newMaxSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时调整拒绝策略</span></span><br><span class="line">executor.setRejectedExecutionHandler(newHandler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>预热线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预创建所有核心线程</span></span><br><span class="line">executor.prestartAllCoreThreads();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>合理设置队列容量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据内存和响应时间要求设置合适的队列大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">queueCapacity</span> <span class="operator">=</span> calculateOptimalQueueSize();</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(queueCapacity);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="什么是乐观锁，什么是悲观锁"><a href="#什么是乐观锁，什么是悲观锁" class="headerlink" title="什么是乐观锁，什么是悲观锁"></a>什么是乐观锁，什么是悲观锁</h3><p>乐观锁是一种乐观思想，<strong>即认为读多写少</strong>，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候<strong>会判断一下在此期间别人有没有去更新这个数据</strong>，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<blockquote>
<p>说人话就是先放着给你，纯看自觉，你没动就无所谓，你动了被他发现他就给你锁上了</p>
</blockquote>
<p>悲观锁是就是悲观思想，<strong>即认为写多</strong>，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以<strong>每次在读写数据的时候都会上锁</strong>，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</p>
<blockquote>
<p>说人话就是疑心太重，不管你感不感兴趣都会把资源给锁上</p>
</blockquote>
<hr>
<p>此处提前占位，是锁相关的部分</p>
<hr>
<h3 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a>线程与进程的区别？</h3><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p>
<p>一个程序至少有一个进程,一个进程至少有一个线程。</p>
<h3 id="什么是多线程中的上下文切换？"><a href="#什么是多线程中的上下文切换？" class="headerlink" title="什么是多线程中的上下文切换？"></a>什么是多线程中的上下文切换？</h3><p>多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU发生的切换数据等就是上下文切换。</p>
<h3 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h3><p>采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java-中的四种引用"><a href="#Java-中的四种引用" class="headerlink" title="Java 中的四种引用"></a>Java 中的四种引用</h3><p>Java中提供了四种类型的引用：强、软、弱、虚<br><strong>强引用</strong><br>强引用是我们最经常使用的引用方式，强引用的对象将不会被垃圾回收器回收，如果引用过多，可能会导致内存泄漏。<br><strong>软引用</strong><br>软引用对象一般情况下不会被回收，但是当内存不足时，软引用将会被垃圾回收器收。<br><strong>弱引用</strong><br>当垃圾回收器（GC）运行时，无论内存是否充足，弱引用指向的对象都会被回收。<br><strong>虚引用</strong><br>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收</p>
<h3 id="常见垃圾回收算法"><a href="#常见垃圾回收算法" class="headerlink" title="常见垃圾回收算法"></a>常见垃圾回收算法</h3><p><strong>1）.清除算法</strong></p>
<ul>
<li>工作原理<br>标记阶段：遍历对象图，标记所有可达对象。<br>清除阶段：清除未标记的不可达对象，回收内存。</li>
</ul>
<p><strong>2）.复制算法</strong></p>
<ul>
<li>工作原理</li>
</ul>
<p>将内存分为两块，每次只使用其中一块。<br>当一块内存满了时，将可达对象复制到另一块内存，并清空原来的内存。</p>
<p><strong>3）.整理算法</strong></p>
<ul>
<li>工作原理<br>标记阶段：标记所有可达对象。<br>整理阶段：将存活对象移动到内存的一端，清理掉其他空间。</li>
</ul>
<p><strong>4）.分代回收算法</strong></p>
<ul>
<li>工作原理<br>将堆内存划分为多个区域：<br>新生代：存放短生命周期的对象。采用复制算法<br>老年代：存放长生命周期的对象。采用标记-清除或标记-整理算法</li>
</ul>
<h3 id="GC-是什么？为什么要有-GC？"><a href="#GC-是什么？为什么要有-GC？" class="headerlink" title="GC 是什么？为什么要有 GC？"></a>GC 是什么？为什么要有 GC？</h3><p>在Java中，GC指的是垃圾回收，是一种自动内存管理的机制。在Java中，程序员不需要手动地去释放内存，垃圾回收器会自动识别和回收不再使用的对象，从而释放内存空间。<br><strong>为什么需要GC</strong></p>
<ul>
<li>防止内存泄漏（该回收的对象没有被回收）</li>
<li>避免手动管理内存的复杂性</li>
<li>提高开发效率，程序员不用操心内存释放<br><strong>GC的工作原理</strong><br>Java的垃圾回收器通过不断扫描内存空间，识别并回收不再使用的对象。当一个对象不再被任何引用指向时，垃圾回收器就会将其标记为垃圾对象，并释放其所占用的内存空间。</li>
</ul>
<p>垃圾回收器的工作可以分为<strong>三个阶段：标记、清除和压缩。</strong></p>
<ol>
<li>标记阶段（Marking）：垃圾回收器会从方法区中的类开始，递归地遍历所有可达（存活的）对象，像侦探一样追踪所有可达对象，并打上标记。没被标记的就是垃圾。</li>
<li>清除(Sweep)：垃圾回收器会扫描整个堆内存，清除所有未被标记的对象，这些未被标记的对象就是垃圾对象，释放它们占用的内存。</li>
<li>压缩(Compact)：在清除完成后，垃圾回收器会对存活对象进行压缩操作，以便整理出更大的连续内存空间。</li>
</ol>
<h3 id="Java堆内存的分代设计"><a href="#Java堆内存的分代设计" class="headerlink" title="Java堆内存的分代设计"></a>Java堆内存的分代设计</h3><p>Java 的内存管理涉及多个部分，最主要的包括 堆内存 和 栈内存，以及 方法区。JVM 会将内存划分为多个区域。<br><strong>堆内存</strong><br>Java把堆内存分成几个”小区”，不同”年龄”的对象住在不同区域：</p>
<ul>
<li><p>新生代：用于存放新创建的对象，对象的生命周期较短，大部分对象都会在短时间内被回收。最终经过多次垃圾回收后仍然存活的对象会被晋升到老年代。</p>
</li>
<li><p>老年代：用于存放存活时间较长的对象，对象的生命周期较长，需要经过多次垃圾回收才能被回收。<br><strong>栈内存</strong><br>栈内存存储的是方法调用时创建的局部变量。栈内存由 JVM 自动管理，栈空间是线程私有的，并且随着方法的调用和结束而自动分配和释放。<br><strong>方法区</strong><br>方法区（也叫 永久代，但在 Java 8 之后被替换为 元空间 Metaspace）存储类信息、常量、静态变量等。</p>
</li>
</ul>
<h3 id="常用的-jvm-调优的参数都有哪些？（列出几种就可以）"><a href="#常用的-jvm-调优的参数都有哪些？（列出几种就可以）" class="headerlink" title="常用的 jvm 调优的参数都有哪些？（列出几种就可以）"></a>常用的 jvm 调优的参数都有哪些？（列出几种就可以）</h3><ol>
<li>-Xmx20M ：表示设置 JVM 启动内存的最大值为 20M，</li>
<li>-verbose:gc：表示输出虚拟机中 GC 的详细情况</li>
<li>-Xss128k ：表示可以设置虚拟机栈的大小为 128k</li>
<li>-Xoss128k ：表示设置本地方法栈的大小为 128k</li>
<li>-Xnoclassgc ：表示关闭 JVM 对类的垃圾回收</li>
<li>-Xmn20M ：表示设置年轻代的大小为 20M</li>
</ol>
<h3 id="说一下-jvm-调优的工具？"><a href="#说一下-jvm-调优的工具？" class="headerlink" title="说一下 jvm 调优的工具？"></a>说一下 jvm 调优的工具？</h3><ol>
<li>Jconsole : jdk 自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很<br>详细的跟踪。</li>
<li>JProfiler：商业软件，需要付费。功能强大。</li>
<li>VisualVM：JDK 自带，功能强大，与 JProfiler 类似。</li>
</ol>
<h3 id="加载class文件的原理机制"><a href="#加载class文件的原理机制" class="headerlink" title="加载class文件的原理机制"></a>加载class文件的原理机制</h3><p>Java文件通过Java 编译器（如 javac）将 Java 源代码（.java 文件）编译而生成的。编译器将 Java 代码转换成字节码，存储在 Class 文件中，Class 文件需要加载到虚拟机中之后才能运行和使用。</p>
<p><strong>类加载的过程</strong><br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：<br><code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>、<code>使用</code>和<code>卸载（Unloading）</code>。</p>
<p>JVM中内置的三个重要类加载器</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）</li>
<li>扩展类加载器（Extension ClassLoader）</li>
<li>系统类加载器（System ClassLoader）<blockquote>
<p>特殊提示：final static常量在准备阶段就赋值，是唯一例外</p>
</blockquote>
</li>
</ul>
<h3 id="堆内存和栈内存的区别"><a href="#堆内存和栈内存的区别" class="headerlink" title="堆内存和栈内存的区别"></a>堆内存和栈内存的区别</h3><p><strong>栈</strong>是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；</p>
<p><strong>堆</strong>是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连<br>续，会有碎片。</p>
<p><strong>1、功能不同</strong><br>栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。<br><strong>2、共享性不同</strong><br>栈内存是线程私有的。</p>
<p>堆内存是所有线程共有的。<br><strong>3、异常错误不同</strong></p>
<p>如果栈内存或者堆内存不足都会抛出异常。</p>
<ul>
<li>栈空间不足：java.lang.StackOverFlowError。</li>
<li>堆空间不足：java.lang.OutOfMemoryError。</li>
</ul>
<p><strong>4、空间大小</strong><br>栈的空间大小远远小于堆的</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最 终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</p>
<h3 id="JVM内存模型包括哪些部分"><a href="#JVM内存模型包括哪些部分" class="headerlink" title="JVM内存模型包括哪些部分"></a>JVM内存模型包括哪些部分</h3><p>JVM内存模型包括：<br>方法区（Method Area）：存储类信息、常量、静态变量等。<br>堆（Heap）：存储对象实例。<br>栈（Stack）：存储局部变量和方法调用。<br>程序计数器（Program Counter Register）：记录当前线程执行的字节码指令地址。<br>本地方法栈（Native Method Stack）：用于执行本地方法。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放</p>
<p>造成死锁的四个条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h3><p>这两位的中文为：同步锁和易失性变量</p>
<p>volatile只能修饰变量，synchronized 既能修饰变量，也能修饰方法和代码块。<br>volatile保证变量的可见性，但不保证原子性；synchronized同时保证可见性和原子性。<br>volatile不会造成线程阻塞，而 synchronized 可能会导致线程阻塞。<br>volatile不能被编译器优化，而 synchronized 通过 JVM 的优化（如偏向锁、轻量级锁）能提高性能。</p>
<h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ol>
<li>synchronized是Java关键字，基于JVM实现自动锁管理；Lock是接口，需手动加锁解锁。</li>
<li>Lock支持非阻塞尝试锁（tryLock）、可中断锁、超时锁，synchronized无法实现。</li>
<li>Lock可设置公平/非公平策略，synchronized仅支持非公平锁。</li>
<li>Lock可通过Condition绑定多个条件，synchronized仅一个等待队列。</li>
<li>高并发时Lock更高效，synchronized优化后差距缩小，但Lock需显式释放避免死锁。</li>
</ol>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="什么是-Mybatis？"><a href="#什么是-Mybatis？" class="headerlink" title="什么是 Mybatis？"></a>什么是 Mybatis？</h3><p>1、<u>Mybatis 是一个<em>半 ORM（对象关系映射）框架</em>，它内部封装了 <code>JDBC</code>，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程</u>。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</p>
<p>2、MyBatis 可以<strong>使用 XML 或注解来配置和映射原生信息</strong>，将 <code>POJO</code> 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>3、通过 xml 文件或注解的方式将要执行的各种 <code>statement</code>配置起来，并通过java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返回 result 的过程）。</p>
<blockquote>
<p>半 ORM（对象关系映射）框架，指的是它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句。</p>
</blockquote>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ol>
<li>单例（Singleton）模式：某个类只能生成一个实例（单例模式常见的实现方法有恶汉式、懒汉式）</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分</li>
</ol>
<h3 id="“-和-”的区别是什么？"><a href="#“-和-”的区别是什么？" class="headerlink" title="“#{}和${}”的区别是什么？"></a>“#{}和${}”的区别是什么？</h3><p>“#{}是预编译处理，${}是字符串替换。”</p>
<p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的set 方法来赋值；</p>
<p>Mybatis 在处理${}时，就是把${}替换成变量的值。</p>
<p>使用#{}可以有效的防止 SQL 注入，提高系统安全性</p>
<blockquote>
<p>他们都是在sql语句中进行赋值操作的部分的语法格式，至于他们两个的区别，#{}就像是在平台上下单，而${}是直接给店家打电话叫人送，前者的安全性和保密性明显更好</p>
</blockquote>
<ul>
<li>用#{}防黑客（用户输入）</li>
<li>用${}拼SQL（结构部分）</li>
</ul>
<h3 id="Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？"><a href="#Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？" class="headerlink" title="Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？"></a>Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？</h3><p>Mybatis 动态 sql可在Xml映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值完成逻辑判断并动态拼接 sql 的功能。<br>Mybatis 提供了9 种动态 sql 标签 ：trim | where | set | foreach | if | choose| when | otherwise | bind。</p>
<h3 id="MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>MyBatis 实现一对一有几种方式?具体怎么操作的？</h3><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap 里面配置 association 节点配置一对一的类就可以完成；<br>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置</p>
<h3 id="MyBatis-实现一对多有几种方式-怎么操作的？"><a href="#MyBatis-实现一对多有几种方式-怎么操作的？" class="headerlink" title="MyBatis 实现一对多有几种方式,怎么操作的？"></a>MyBatis 实现一对多有几种方式,怎么操作的？</h3><p>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap 里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的<br>结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。</p>
<h3 id="Mybatis-的一级、二级缓存"><a href="#Mybatis-的一级、二级缓存" class="headerlink" title="Mybatis 的一级、二级缓存"></a>Mybatis 的一级、二级缓存</h3><p><strong>一级缓存</strong>：SqlSession级别的缓存，默认开启<br>MyBatis的一级缓存也是SqlSession的缓存，SqlSession对象中维护了一个Map集合，用于存储相互的缓存数据。<br>查询的时候，先从SqlSession的缓存中查找，如果有，直接返回。如果没有，查询数据库。</p>
<p><strong>二级缓存</strong>：全局缓存，基于Mapper实现，默认关闭<br>开启二级缓存配置：<br>1.全局启用（在 mybatis-config.xml 中配置）：cacheEnabled 为true（默认true）<br>2.Mapper配置文件中配置： <cache/></p>
<h3 id="mybatis-有几种分页方式？"><a href="#mybatis-有几种分页方式？" class="headerlink" title="mybatis 有几种分页方式？"></a>mybatis 有几种分页方式？</h3><p>数组分页，SQL 分页，拦截器分页，RowBounds 分页</p>
<h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="数据库存储引擎"><a href="#数据库存储引擎" class="headerlink" title="数据库存储引擎"></a>数据库存储引擎</h3><p>数据库存储引擎决定了数据的存储和检索方式，以及如何处理数据的查询、插入、更新和删除操作。从MySQL 5.5版本开始，MySQL支持多种存储引擎：<br><code>InnoDB</code>：默认存储引擎支持事务处理（ACID兼容）、行级锁定、外键约束<br><code>MyISAM</code>：不支持事务处理，但支持全文索引、压缩表、空间函数<br><code>MEMORY</code>：数据存储在内存中，速度快，适合临时表或需要快速访问的数据 </p>
<h3 id="InnoDB与MyISAM的区别"><a href="#InnoDB与MyISAM的区别" class="headerlink" title="InnoDB与MyISAM的区别"></a>InnoDB与MyISAM的区别</h3><ol>
<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>
<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高</li>
</ol>
<h3 id="什么是索引，索引的作用？"><a href="#什么是索引，索引的作用？" class="headerlink" title="什么是索引，索引的作用？"></a>什么是索引，索引的作用？</h3><p>索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>
<p>mysql 有4种不同的索引：<br>主键索引（PRIMARY）<br>唯一索引（UNIQUE）<br>普通索引（INDEX）<br>全文索引（FULLTEXT</p>
<h3 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h3><p>第一范式：列不可再分<br>第二范式：行可以唯一区分，主键约束<br>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束<br>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上 。</p>
<h3 id="什么是数据库事务？事务的特性有哪些？事务的隔离级别？分别处理那些问题"><a href="#什么是数据库事务？事务的特性有哪些？事务的隔离级别？分别处理那些问题" class="headerlink" title="什么是数据库事务？事务的特性有哪些？事务的隔离级别？分别处理那些问题"></a><strong>什么是数据库事务？事务的特性有哪些？事务的隔离级别？分别处理那些问题</strong></h3><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作， 这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元事务必须具备以下四个属性，简称 ACID 属性：</p>
<p><strong>原子性（Atomicity）</strong></p>
<p>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执<br>行。</p>
<p><strong>一致性（Consistency）</strong></p>
<p>当事务完成时，数据必须处于一致状态。</p>
<p><strong>隔离性（Isolation）</strong></p>
<p>对数据进行修改的所有并发事务是彼此隔离的， 这表明事务必须是独立的，它不应以任何方<br>式依赖于或影响其他事务。</p>
<p><strong>永久性（Durability）</strong></p>
<p>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性</p>
<p><strong>SQL 标准定义了四个隔离级别：</strong> </p>
<p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>
<p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生 </p>
<p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰</p>
<h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><p>事务在操作时的理想状态： 所有的事务之间保持隔离，互不影响。因为并发操作，多个用户同时访问同一个数据，可能引发并发访问的问题。<br>1). 赃读：一个事务读到另外一个事务还没有提交的数据。<br>2). 不可重复读：一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致<br>的，这是事务update时引发的问题。<br>3).幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经<br>存在，好像出现了 “幻影”。</p>
<h3 id="如何对SQL优化"><a href="#如何对SQL优化" class="headerlink" title="如何对SQL优化"></a>如何对SQL优化</h3><p>1、查询语句中不要使用select *<br>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代<br>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代<br>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好)<br>5、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<h3 id="简单说一说drop、delete与truncate的区别"><a href="#简单说一说drop、delete与truncate的区别" class="headerlink" title="简单说一说drop、delete与truncate的区别"></a>简单说一说drop、delete与truncate的区别</h3><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别<br>delete和truncate只删除表的数据不删除表的结构<br>速度上,一般来说: drop&gt; truncate &gt;delete<br>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollbacksegment中,不能回滚. 操作不触发trigger</p>
<h3 id="什么是视图，视图的优点是什么？"><a href="#什么是视图，视图的优点是什么？" class="headerlink" title="什么是视图，视图的优点是什么？"></a>什么是视图，视图的优点是什么？</h3><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询</p>
<p><strong>视图的优点（视图的作用）：</strong></p>
<p>(1) 视图能够简化用户的操作<br>(2) 视图使用户能以多种角度看待同一数据；<br>(3) 视图为数据库提供了一定程度的逻辑独立性；<br>(4) 视图能够对机密数据提供安全保护</p>
<h3 id="多表查询的分类"><a href="#多表查询的分类" class="headerlink" title="多表查询的分类"></a>多表查询的分类</h3><p>交叉连接：返回两表所有可能的组合（笛卡尔积）<br>内连接（INNER JOIN）：返回两个表中有匹配关系的记录。隐式内连接使用逗号分隔表名，显式内连接需明确指定INNER关键字。<br>外连接</p>
<ol>
<li>左外连接（LEFT JOIN）：返回左表所有记录，右表无匹配时对应列填充NULL。 </li>
<li>右外连接（RIGHT JOIN）：返回右表所有记录，左表无匹配时对应列填充NULL。 </li>
<li>全外连接（FULL JOIN）：结合左、右外连接的结果，只要任一表存在匹配则返回行。<br>自连接：当前表与自身进行连接查询，需使用别名区分不同实例<br>子查询：</li>
<li>列子查询：返回单列值</li>
<li>行子查询：返回单行数据 </li>
<li>表子查询：返回整个子查询结果集作为临时表</li>
</ol>
<h3 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h3><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br><strong>丢失修改（Lost to modify）</strong>: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。<br><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<br><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p><strong>不可重复读和幻读区别：</strong><br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了</p>
<h3 id="遇上大表如何优化？"><a href="#遇上大表如何优化？" class="headerlink" title="遇上大表如何优化？"></a>遇上大表如何优化？</h3><p><strong>限定数据的范围</strong><br>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；<br><strong>读/写分离</strong><br>经典的数据库拆分方案，主库负责写，从库负责读；<br><strong>垂直分区</strong><br>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<h3 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h3><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p>
<h3 id="MySQL-中有哪几种锁？"><a href="#MySQL-中有哪几种锁？" class="headerlink" title="MySQL 中有哪几种锁？"></a>MySQL 中有哪几种锁？</h3><p>1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h3 id="CHAR-和-VARCHAR-的区别？"><a href="#CHAR-和-VARCHAR-的区别？" class="headerlink" title="CHAR 和 VARCHAR 的区别？"></a>CHAR 和 VARCHAR 的区别？</h3><p>1、CHAR 和 VARCHAR 类型在存储和检索方面有所不同<br>2、CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255 当 CHAR值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。</p>
<h3 id="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题"><a href="#对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题" class="headerlink" title="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题"></a>对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题</h3><h4 id="1、索引的目的是什么？"><a href="#1、索引的目的是什么？" class="headerlink" title="1、索引的目的是什么？"></a>1、索引的目的是什么？</h4><p>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p>
<h4 id="2、索引对数据库系统的负面影响是什么？"><a href="#2、索引对数据库系统的负面影响是什么？" class="headerlink" title="2、索引对数据库系统的负面影响是什么？"></a>2、索引对数据库系统的负面影响是什么？</h4><p><strong>负面影响：</strong><br>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也<br>需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p>
<h4 id="3、为数据表建立索引的原则有哪些？"><a href="#3、为数据表建立索引的原则有哪些？" class="headerlink" title="3、为数据表建立索引的原则有哪些？"></a>3、为数据表建立索引的原则有哪些？</h4><p>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引</p>
<h4 id="4、什么情况下不宜建立索引？什么情况下宜建立索引？"><a href="#4、什么情况下不宜建立索引？什么情况下宜建立索引？" class="headerlink" title="4、什么情况下不宜建立索引？什么情况下宜建立索引？"></a>4、什么情况下不宜建立索引？什么情况下宜建立索引？</h4><p><strong>哪些情况需要创建索引</strong></p>
<ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
</ol>
<p><strong>哪些情况不需要创建索引</strong></p>
<ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>where条件里用不到的字段不建立索引<h4 id="5、索引的优缺点是什么"><a href="#5、索引的优缺点是什么" class="headerlink" title="5、索引的优缺点是什么"></a>5、索引的优缺点是什么</h4>【1】索引的优点</li>
<li>大大加快数据查询速度，类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本</li>
</ol>
<p>【2】索引的缺点</p>
<ol>
<li>创建索引和维护索引要 耗费时间 ，并 且随着数据量的增加，所耗费的时间也会增加</li>
<li>索引需要占用磁盘空间</li>
<li>虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。<h3 id="SQL-语言包括哪几部分？每部分都有哪些操作关键"><a href="#SQL-语言包括哪几部分？每部分都有哪些操作关键" class="headerlink" title="SQL 语言包括哪几部分？每部分都有哪些操作关键"></a>SQL 语言包括哪几部分？每部分都有哪些操作关键</h3></li>
</ol>
<p>SQL 语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。<br>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index 等<br>数据操纵：Select ,insert,update,delete,<br>数据控制：grant,revoke<br>数据查询：select</p>
<h3 id="说说对-SQL-语句优化有哪些方法？"><a href="#说说对-SQL-语句优化有哪些方法？" class="headerlink" title="说说对 SQL 语句优化有哪些方法？"></a><strong>说说对</strong> <strong>SQL</strong> <strong>语句优化有哪些方法？</strong></h3><p>1、Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。<br>2、用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。<br>3、 避免在索引列上使用计算<br>4、避免在索引列上使用 IS NULL 和 IS NOT NULL<br>5、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。<br>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描<br>7、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
<h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>在并发访问的情况下，多个用户可能同时对同一张表进行读取或写入操作，这些操作可能会导致数据的不一致或损坏。而锁是实现一致性的最终兜底方案，在某些特殊场景下，锁的使用不可避免<br>在 MySQL 中，锁是数据库管理系统用于控制并发访问的机制，确保数据的安全性和一致性。</p>
<p>MySQL中的锁，分为以下三类：</p>
<p><code>全局锁</code>：锁定数据库中的所有表。<br><code>表级锁</code>：每次操作锁住整张表。<br><code>行级锁</code>：每次操作锁住对应的行数据。<br><code>全局锁</code>：全局读锁会让所有的表都加上一个读锁，阻止对这些表的写操作，但是仍然允许读操作。<br><code>表级锁</code>：意思就是每次操作锁住整张表。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<br><code>行级锁</code>：每次操作锁住对应的行数据，InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁，对于行级锁，主要分为三类：</p>
<ol>
<li>记录锁（Record Lock）：直接锁定被操作的数据行。用于保护单个记录，防止其他事务对此行进<br>行 update 和 delete 操作。</li>
<li>间隙锁（Gap Lock）：锁定索引记录间隙，防止别人插新页（新数据），防幻读。</li>
<li>临键锁（Next-Key Lock）：行锁 + 间隙锁一起上，同时锁住数据。</li>
</ol>
<p>两种类型的行锁：<br><code>共享锁</code>：又称为S锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。<br><code>排他锁</code>：又称为X锁，允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p>
<h3 id="什么是时间戳"><a href="#什么是时间戳" class="headerlink" title="什么是时间戳"></a>什么是时间戳</h3><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”， 每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，以上悲观锁所说的加“锁”，其实分为几种锁，分别是： 排它锁（写锁）和共享锁（读锁） 。</p>
<h2 id="LINUX部分"><a href="#LINUX部分" class="headerlink" title="LINUX部分"></a>LINUX部分</h2><h3 id="绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示-切换目录用什么命令？"><a href="#绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示-切换目录用什么命令？" class="headerlink" title="绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？"></a>绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</h3><p>绝对路径： 如/etc/init.d<br>当前目录和上层目录： ./ ../<br>主目录： ~/<br>切换目录： cd</p>
<h3 id="怎么查看当前进程？怎么执行退出？怎么查看当前路径？"><a href="#怎么查看当前进程？怎么执行退出？怎么查看当前路径？" class="headerlink" title="怎么查看当前进程？怎么执行退出？怎么查看当前路径？"></a>怎么查看当前进程？怎么执行退出？怎么查看当前路径？</h3><p>查看当前进程： ps<br>执行退出： exit<br>查看当前路径： pwd</p>
<h3 id="怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户-id？查看指定帮助用什么命令？"><a href="#怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户-id？查看指定帮助用什么命令？" class="headerlink" title="怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？"></a>怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？</h3><p>清屏： clear</p>
<p>退出当前命令： ctrl+c 彻底退出</p>
<p>执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台 查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名</p>
<p>查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser —help 这个告诉你一些常用参数； info adduesr；</p>
<h3 id="Ls-命令执行什么功能？-可以带哪些参数，有什么区别？"><a href="#Ls-命令执行什么功能？-可以带哪些参数，有什么区别？" class="headerlink" title="Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？"></a>Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？</h3><p>ls 执行的功能： 列出指定目录中的目录，以及文件哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等</p>
<h3 id="列举几个常用的Linux命令"><a href="#列举几个常用的Linux命令" class="headerlink" title="列举几个常用的Linux命令"></a>列举几个常用的Linux命令</h3><p>列出文件列表：ls【参数 -a -l】<br>创建目录和移除目录：mkdir rm-dir<br>用于显示文件后几行内容：tail，例如： tail -n 1000：显示最后1000行<br>解压：tar -xvf<br>打包并压缩：tar -zcvf<br>查找字符串：grep<br>显示当前所在目录：pwd创建空文件：touch<br>编辑器：vim vi</p>
<blockquote>
<p>要看更多命令，请见<a href="http://xhayane.top/2025/07/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/">点击这里看更多</a></p>
</blockquote>
<h3 id="使用什么命令查看磁盘使用空间？-空闲空间呢"><a href="#使用什么命令查看磁盘使用空间？-空闲空间呢" class="headerlink" title="使用什么命令查看磁盘使用空间？ 空闲空间呢?"></a>使用什么命令查看磁盘使用空间？ 空闲空间呢?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -hl  </span><br></pre></td></tr></table></figure>
<h3 id="使用什么命令查看网络是否连通-使用什么命令查看-ip-地址及接口信息？"><a href="#使用什么命令查看网络是否连通-使用什么命令查看-ip-地址及接口信息？" class="headerlink" title="使用什么命令查看网络是否连通,使用什么命令查看 ip 地址及接口信息？"></a>使用什么命令查看网络是否连通,使用什么命令查看 ip 地址及接口信息？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看网络是否连通</span><br><span class="line">netsatar</span><br><span class="line"># 查看IP地址及接口信息</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<h3 id="查看各类环境变量用什么命令"><a href="#查看各类环境变量用什么命令" class="headerlink" title="查看各类环境变量用什么命令?"></a>查看各类环境变量用什么命令?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看所有 env</span><br><span class="line">查看某个，如 home： env $HOME</span><br></pre></td></tr></table></figure>
<hr>
<p>其余指令和多余的命令指正在施工</p>
<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="使用Redis有哪些好处？"><a href="#使用Redis有哪些好处？" class="headerlink" title="使用Redis有哪些好处？"></a>使用Redis有哪些好处？</h3><ol>
<li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是0</li>
<li>支持丰富数据类型，支持string，list，set，sorted set，hash</li>
<li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>
<li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li>
</ol>
<h3 id="Redis的数据类型？"><a href="#Redis的数据类型？" class="headerlink" title="Redis的数据类型？"></a>Redis的数据类型？</h3><p>Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset（有序集合）。</p>
<h3 id="什么是Redis事务？"><a href="#什么是Redis事务？" class="headerlink" title="什么是Redis事务？"></a>什么是Redis事务？</h3><p>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。<br>Redis 可以通过 MULTI、EXEC、DISCARD 和 WATCH 等命令来实现事务（Transaction）功能</p>
<h3 id="缓存雪崩、缓存穿透、缓存预热、等问题"><a href="#缓存雪崩、缓存穿透、缓存预热、等问题" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、等问题"></a>缓存雪崩、缓存穿透、缓存预热、等问题</h3><p><strong>【1】缓存雪崩</strong><br>由于原有缓存失效，新缓存未到期间，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>解决办法：<br>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p>
<p><strong>【2】缓存穿透</strong><br>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p>解决办法<br>最常见的则是采用布隆过滤器</p>
<p><strong>【3】缓存预热</strong><br>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据。</p>
<p>解决思路：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存</li>
</ol>
<h3 id="Redis-持久化有几种方式？"><a href="#Redis-持久化有几种方式？" class="headerlink" title="Redis 持久化有几种方式？"></a>Redis 持久化有几种方式？</h3><ol>
<li>RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。</li>
<li>AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在redis重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。</li>
</ol>
<h3 id="Redis是单进程单线程的？"><a href="#Redis是单进程单线程的？" class="headerlink" title="Redis是单进程单线程的？"></a>Redis是单进程单线程的？</h3><p>Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<h3 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h3><ol>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞I/O多路复用机制</li>
</ol>
<h2 id="操作系统部分"><a href="#操作系统部分" class="headerlink" title="操作系统部分"></a>操作系统部分</h2><h3 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h3><p>并发是多个任务在同一时间段内交替执行<br>并行是多个任务在同一时刻真正同时执行</p>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p><strong>进程：</strong>内存中运行的运用程序，每个进程都有自己独立的内存空间，一个进程可以由多个线程，例如在Windows系统中，xxx.exe就是一个进程。</p>
<p><strong>线程：</strong>进程中的一个控制单元，负责当前进程中的程序执行，一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可以共享数据。</p>
<h3 id="Java用到的线程调度算法是什么？"><a href="#Java用到的线程调度算法是什么？" class="headerlink" title="Java用到的线程调度算法是什么？"></a>Java用到的线程调度算法是什么？</h3><p>计算机通常只有一个CPU，在任意时刻只能执行一条机器指令，每个线程只有获取到CPU的使用权才能执行指令，所谓多线程的并发运行，其实从宏观上看，各线程轮流获取CPU的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待，CPU的调度，JVM有一项任务就是负责CPU的调度，线程调度就是按照特定的机制为多个线程分配CPU的使用权。</p>
<p>有两种调度模型：分时调度和抢占式调度<br><strong>分时调度：</strong>就是让所有的线程轮流获得CPU的使用权，并且平均分配到各个线程占有CPU的时间片。<br><strong>抢占式调度：</strong>Java虚拟机采用抢占式调度模型，是指优先让线程池中优先级高的线程首先占用<br>CPU，如果线程池中优先级相同，那么随机选择一个线程，使其占有CPU，处于这个状态的CPU会一直运行，优先级高的分的CPU的时间片相对会多一点</p>
<h3 id="什么是线程调度-Thread-Scheduler-和时间分片-Time-Slicing"><a href="#什么是线程调度-Thread-Scheduler-和时间分片-Time-Slicing" class="headerlink" title="什么是线程调度(Thread Scheduler)和时间分片(Time Slicing )"></a>什么是线程调度(Thread Scheduler)和时间分片(Time Slicing )</h3><p><strong>线程调度</strong>是一个操作系统服务，它负责为储在Runnable状态的线程分配CPU时间片，一旦我们创建一个线程并启动它，它的执行便依赖线程调度器的实现。</p>
<p><strong>时间分片</strong>是指CPU可用时间分配给Runnable的过程，分配的时间可以根据线程优先级或线程等待时间。</p>
<h2 id="spring部分"><a href="#spring部分" class="headerlink" title="spring部分"></a>spring部分</h2><h3 id="什么是spring？spring的核心机制是什么？"><a href="#什么是spring？spring的核心机制是什么？" class="headerlink" title="什么是spring？spring的核心机制是什么？"></a>什么是spring？spring的核心机制是什么？</h3><p>Spring的核心控制反转（IOC）和面向切面（AOP），简单来说Spring是一个分层JavaEE一站式轻量级开源框架。</p>
<p><strong>IOC和AOP是spring的核心机制</strong></p>
<p><strong>IOC:</strong>控制反转/依赖注入，在之前学习的过程中，比如有一个类，我们想要调用类里面的方法，就要创建该类的对象，使用对象调用方法来实现。但是对于Spring来说，不用再自己创建要使用的对象，而是由Spring容器统一管理，自动注入，注入就是赋值</p>
<p><strong>AOP:</strong>面向切面编程，简单来说就是我们可以在不修改源码的情况下，对程序的方法进行增强，将涉及多业务流程的通用功能抽取并单独封装，形成独立的切面，再合适的时机将这些切面横向切入到业务流程的指定的位置中</p>
<h3 id="spring中有多少个模块？有那几部分构成"><a href="#spring中有多少个模块？有那几部分构成" class="headerlink" title="spring中有多少个模块？有那几部分构成"></a>spring中有多少个模块？有那几部分构成</h3><blockquote>
<p>核心容器模块，数据访问和集成模块，web模块，AOP 和 Aspect 模块，测试模块</p>
</blockquote>
<p>首先是<strong>核心容器模块</strong>，这是 Spring 的基础，包括 Core、Bean、Context 和 SpEL。Core 和 Bean 提供了 IoC 容器的核心实现，负责 Bean 的定义、创建和依赖注入；Context 基于前两者扩展，增加了国际化、事件传播等企业级功能；SpEL 是表达式语言，方便在配置中动态操作对象。</p>
<p>然后是 <strong>数据访问与集成模块</strong>，主要包括 JDBC、ORM、Transactions 等。JDBC 提供模板类简化数据库操作；ORM 集成了 Hibernate、MyBatis 等框架，统一了持久层编程模型；Transactions 支持声明式事务，通过注解或配置就能管理事务，不用手动写代码控制。</p>
<p>接下来是 <strong>Web 模块</strong>，分为 Web、Web MVC、Web Socket 等。Web 模块支持在 Web 环境下初始化 IoC 容器；Web MVC 就是 Spring MVC，负责请求分发、视图解析等，是 Web 开发的核心；还有针对 WebSocket 等实时通信的支持。</p>
<p>另外还有 <strong>AOP 和 Aspect 模块</strong>，提供面向切面编程的能力，比如日志、权限、事务等横切逻辑可以通过 AOP 统一处理，Aspect 模块则集成了 AspectJ 框架，增强了 AOP 的功能。</p>
<p>最后还有 <strong>测试模块</strong>，比如 Test 模块，支持用 JUnit、Mockito 等框架测试 Spring 组件，提供了依赖注入、事务回滚等测试支持，方便单元测试和集成测试。</p>
<h3 id="Spring的IOC和AOP机制（这个相当的重要）"><a href="#Spring的IOC和AOP机制（这个相当的重要）" class="headerlink" title="Spring的IOC和AOP机制（这个相当的重要）"></a>Spring的IOC和AOP机制（这个相当的重要）</h3><p><strong>什么是控制反转(IOC)？什么是依赖注入（DI）</strong></p>
<p>IOC：就是对象之间的依赖关系由容器来创建，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。</p>
<p>DI：将属性值注入给了属性，将属性注入给了bean，将bean注入给了ioc容器。</p>
<p><strong>AOP即面向切面编程</strong><br>Spring 中的 AOP是一种编程思想，它将程序中的横切关注点（如日志、事务等）从业务逻辑代码中分离出来，以提高代码的可重用性和可维护性。</p>
<p>在 Spring 框架中，AOP 是通过代理模式实现的，即在运行时动态地生成一个代理类，这个代理类会拦截目标对象的方法调用，并在方法执行前后添加相应的横切逻辑。</p>
<h3 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h3><p>实现AOP的技术，主要分为两大类：</p>
<p>静态代理：</p>
<p>指的是使用的AOP框架提供的命令进行编译，而在编译阶段就可以生成AOP代理类，因此也称为编译时增强</p>
<ul>
<li>编译时编织</li>
<li>类加载的时候编织</li>
</ul>
<p>动态代理</p>
<p>指的是在内存中临时生成的AOP动态代理类，因此也被称为运行时增强</p>
<ul>
<li>JDK动态代理</li>
<li>CGLIB</li>
</ul>
<h3 id="何为编织？"><a href="#何为编织？" class="headerlink" title="何为编织？"></a>何为编织？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。</p>
<h3 id="什么是依赖注入？可以通过多少种方式完成依赖注入？"><a href="#什么是依赖注入？可以通过多少种方式完成依赖注入？" class="headerlink" title="什么是依赖注入？可以通过多少种方式完成依赖注入？"></a>什么是依赖注入？可以通过多少种方式完成依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC容器将它们装配在一起。</p>
<p>通常我们我们可以通过三种方式来完成依赖注入</p>
<p><strong>使用构造函数注入，setter注入，接口注入</strong></p>
<p><strong>一、构造器注入</strong><br>将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。<br><strong>优点：</strong>对象初始化完成后便可获得可使用的对象。<br><strong>缺点：</strong>当需要注入的对象很多时，构造器参数列表将会很长；不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。<br><strong>二、setter方法注入</strong><br>IoC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。<br><strong>优点：</strong>灵活。可以选择性地注入需要的对象。<br><strong>缺点：</strong>依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。<br><strong>三、接口注入</strong><br>依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象<br><strong>优点：</strong>接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。<br><strong>缺点：</strong>侵入行太强，不建议使用。</p>
<p>PS：什么是侵入行？<br>如果类A要使用别人提供的一个功能，若为了使用这功能，需要在自己的类中增加额外的代码，这就是侵入性</p>
<h3 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h3><p><strong>基于 xml 配置</strong><br>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。</p>
<p><strong>基于注解配置</strong><br>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。</p>
<p><strong>基于 Java API 配置</strong><br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<br>1、 @Bean 注解扮演与 元素相同的角色。<br>2、 @Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</p>
<h3 id="spring四大注解"><a href="#spring四大注解" class="headerlink" title="spring四大注解"></a>spring四大注解</h3><p>以下注解在某个类上加入任何一个注解能够快速的将这个组件加入到IOC容器的管理中：</p>
<p><strong>@Componet：</strong>（万物起源）容器管理bean的基础注解，应用于具体的实现类上，不属于以下三类时，用此注解。</p>
<p>这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p><strong>@Service：</strong>一般应用于业务层(PersonService)</p>
<p>此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用@Service 而不是@Component，因为它以更好的方式指定了意图。</p>
<p><strong>@Repository：</strong>一般应用于持久层(PersonDao)</p>
<p>这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<p><strong>@Controller：</strong>一般应用于控制层(PersonServlet)</p>
<p>以上注解可以随便加，Spring底层不会去验证你的组件，但是我们推荐各层用各自的注解。</p>
<h3 id="Spring中重要的注解"><a href="#Spring中重要的注解" class="headerlink" title="Spring中重要的注解"></a>Spring中重要的注解</h3><blockquote>
<p>说人话解释：</p>
<p>@Required：属性必须赋值，不赋值就报错<br>@Autowired：自动找匹配类型的 Bean 塞进来<br>@Qualifier：配合 @Autowired，在多个同类型 Bean 中挑指定名字的<br>@RequestMapping：指定哪个 URL 和请求方式由哪个方法处理</p>
</blockquote>
<p><strong>@Required</strong> 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用bean 定义中的显式属性值或使用自动装配填充受影响的 bean属性。如果尚未填充受影响的 bean 属性，则容器将抛出 eanInitializationException。</p>
<p><strong>@Autowired</strong> 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配bean。默认情况下，它是类型驱动的注入。</p>
<p><strong>@Qualifier</strong> 当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean</p>
<p><strong>@RequestMapping</strong> 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：<br>类级别：映射请求的 URL 方法级别：映射 URL 以及 HTTP 请求方法</p>
<h3 id="Autowired和Resource的区别"><a href="#Autowired和Resource的区别" class="headerlink" title="Autowired和Resource的区别"></a>Autowired和Resource的区别</h3><ol>
<li>@Autowired是Spring框架提供的注解，而@Resource是JDK提供的注解。</li>
<li>@Autowired先根据类型查找，如果存在多个Bean，再根据名称查找，</li>
<li>@Resource是按照名称注入，先根据名称查找，如果查找不到，再根据类型查找</li>
</ol>
<h3 id="spring-bean容器的生命周期"><a href="#spring-bean容器的生命周期" class="headerlink" title="spring bean容器的生命周期"></a>spring bean容器的生命周期</h3><blockquote>
<p>生命周期由：实例化——》属性注入——》初始化——》使用状态——》销毁状态</p>
</blockquote>
<p>首先是<strong>实例化</strong>阶段，容器通过反射调用 Bean 的无参构造方法创建实例，这一步只是生成了对象，还没设置任何属性。</p>
<p>接下来是<strong>属性注入</strong>，容器会根据配置（比如 XML 或注解），将依赖的属性值或其他 Bean 注入到当前实例中，完成对象的基本初始化准备。</p>
<p>然后进入<strong>初始化</strong>阶段，这个阶段比较关键，包含多个步骤：</p>
<ul>
<li>如果 Bean 实现了<code>BeanNameAware</code>接口，会调用<code>setBeanName()</code>方法，传入 Bean 的 ID；</li>
<li>若实现<code>BeanFactoryAware</code>接口，调用<code>setBeanFactory()</code>方法，获取当前 BeanFactory 的引用；</li>
<li>若实现<code>ApplicationContextAware</code>接口，会通过<code>setApplicationContext()</code>方法拿到 ApplicationContext；</li>
<li>之后会执行<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization()</code>方法，这是初始化前的扩展点；</li>
<li>接着调用 Bean 自身定义的初始化方法，比如 XML 配置的<code>init-method</code>或<code>@PostConstruct</code>注解标注的方法；</li>
<li>最后执行<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization()</code>方法，像 AOP 代理通常就在这一步生成。</li>
</ul>
<p>初始化完成后，Bean 就进入<strong>使用阶段</strong>，容器会将其提供给应用程序调用。</p>
<p>当容器关闭时，进入<strong>销毁</strong>阶段：</p>
<ul>
<li>若 Bean 实现<code>DisposableBean</code>接口，会调用<code>destroy()</code>方法；</li>
<li>同时会执行自定义的销毁方法，比如 XML 配置的<code>destroy-method</code>或<code>@PreDestroy</code>注解的方法；</li>
<li>最终 Bean 实例被回收，生命周期结束。</li>
</ul>
<h3 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a><strong>自动装配有哪些方式？</strong></h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>
<p><strong>自动装配的不同模式：</strong></p>
<ol>
<li>按名称自动装配（byName）</li>
<li>按类型自动装配（byType）</li>
<li>构造函数自动装配（constructor)</li>
<li>按照默认方式自动装配（default）： byType 进行自动装配</li>
</ol>
<h3 id="设计模式列表（背常见那几个就行）"><a href="#设计模式列表（背常见那几个就行）" class="headerlink" title="设计模式列表（背常见那几个就行）"></a>设计模式列表（背常见那几个就行）</h3><blockquote>
<p>工厂模式用途：通过一个专门的 “工厂” 类来创建对象，你只需要告诉工厂你要什么类型的对象，不用自己动手创建。<br>单例模式用途：保证一个类只有一个实例，并且提供一个全局访问点。<br>代理模式用途：找一个 “代理人” 来帮你处理事情，代理人可以在真正做事之前 / 之后做一些额外操作。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的</th>
<th>范围</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>创建型</strong></td>
<td>类</td>
<td><strong>工厂方法模式 (Factory Method)</strong></td>
<td>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</td>
</tr>
<tr>
<td></td>
<td>对象</td>
<td>抽象工厂模式 (Abstract Factory)</td>
<td>提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>建造者模式 (Builder)</strong></td>
<td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>原型模式 (Prototype)</td>
<td>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>单例模式 (Singleton)</strong></td>
<td>保证一个类仅有一个实例；并提供一个访问它的全局访问点。</td>
</tr>
<tr>
<td><strong>结构型</strong></td>
<td>类</td>
<td>适配器模式 (Adapter)</td>
<td>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>桥接模式 (Bridge)</td>
<td>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</td>
</tr>
<tr>
<td></td>
<td>对象</td>
<td><strong>组合模式 (Composite)</strong></td>
<td>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>装饰模式 (Decorator)</strong></td>
<td>动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>外观模式 (Facade)</td>
<td>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>享元模式 (Flyweight)</td>
<td>运用共享技术有效地支持大量细粒度的对象。</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>代理模式 (Proxy)</strong></td>
<td>为其他对象提供一个代理以控制对这个对象的访问。</td>
</tr>
<tr>
<td><strong>行为型</strong></td>
<td>类</td>
<td>解释器模式 (Interpreter)</td>
<td>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>模板方法模式 (Template Method)</td>
<td>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>责任链模式 (Chain of Responsibility)</td>
<td>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>命令模式 (Command)</td>
<td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>迭代器模式 (Iterator)</td>
<td>提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>中介者模式 (Mediator)</td>
<td>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>备忘录模式 (Memento)</td>
<td>在不破坏封装性的前提下，捕获一个对象的内部状态。</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>观察者模式 (Observer)</strong></td>
<td>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>状态模式 (State)</td>
<td>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>策略模式 (Strategy)</td>
<td>定义一系列的算法，把它们一个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>访问者模式 (Visitor)</td>
<td>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>MVC模式</strong>、<strong>饿汉模式</strong> 和 <strong>懒汉模式</strong> 在上面的表格中没有直接列出，但它们都属于设计模式的范畴，具体分类如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式名称</th>
<th>分类</th>
<th>关联的经典设计模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>MVC模式</td>
<td>架构模式（架构模式本质上不是设计模式）</td>
<td>观察者模式、策略模式</td>
</tr>
<tr>
<td>饿汉模式</td>
<td>单例模式（创建型）</td>
<td>单例模式</td>
</tr>
<tr>
<td>懒汉模式</td>
<td>单例模式（创建型）</td>
<td>单例模式</td>
</tr>
</tbody>
</table>
</div>
<h3 id="什么是-Aspect？切点？通知？"><a href="#什么是-Aspect？切点？通知？" class="headerlink" title="什么是 Aspect？切点？通知？"></a>什么是 Aspect？切点？通知？</h3><p>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中. AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<p>1、如何通过 pointcut 和 advice 定位到特定的 joinpoint 上<br>2、如何在advice 中编写切面代码.</p>
<blockquote>
<p><strong>说人话就是使用 @Aspect 注解的类就是切面</strong></p>
</blockquote>
<p><strong>切点：</strong>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.在 Spring AOP 中, join point 总是方法的执行点</p>
<p><strong>通知：</strong>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><p>MVC全称Model View Controller，是一种设计创建Web应用程序的模式。这三个单词分别代表Web应用程序的三个部分：<br><code>Model（模型）</code>：指数据模型。用于存储数据以及处理用户请求的业务逻辑。在Web应用中，JavaBean对象，用来进行数据封装</p>
<p><code>View（视图）</code>：用于展示模型中的数据的，一般为jsp或html文件。</p>
<p><code>Controller（控制器）</code>：用来接受用户的请求。</p>
<h3 id="简述-MVC、MVVM-的关系与区别"><a href="#简述-MVC、MVVM-的关系与区别" class="headerlink" title="简述 MVC、MVVM 的关系与区别?"></a>简述 MVC、MVVM 的关系与区别?</h3><p>MVC：Model-View-Controller 模型-视图-控制器<br>MVVM：Model-View-ViewModel 模型-视图-视图模型<br><strong>相同点</strong></p>
<ol>
<li>都是为了分离 View 和 Model，M 注重数据，V 注重视图，使 Model 和 View 更易于维护。</li>
</ol>
<p><strong>不同点</strong></p>
<ol>
<li>MVC 是系统架构级别的，MVVM 是用于单页面上的，MVVM 的灵活性大于 MVC。</li>
<li>MVC 是 Controller 从 View 视图层收集数据，然后向相关模型请求数据并返回相应的视图来完成交互请求。</li>
<li>MVVM 本质上是 MVC 的改进版，其最重要的特性是数据绑定，此外还包括依赖注入，路由配置，数据模板等一些特性。</li>
</ol>
<h3 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h3><p>对象关系映射(Object Relational Mapping)，它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。</p>
<h3 id="Spring-MVC框架的作用"><a href="#Spring-MVC框架的作用" class="headerlink" title="Spring MVC框架的作用"></a>Spring MVC框架的作用</h3><p>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="DispatcherServlet-的工作流程（Spring-MVC流程）"><a href="#DispatcherServlet-的工作流程（Spring-MVC流程）" class="headerlink" title="DispatcherServlet 的工作流程（Spring MVC流程）"></a>DispatcherServlet 的工作流程（Spring MVC流程）</h3><blockquote>
<p>这里建议是找个图，我这里就不污染图床了，请自行寻找网图来辅助背诵</p>
</blockquote>
<p>1、 用户发送请求至前端控制器DispatcherServlet。<br>2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。<br>4、 DispatcherServlet调用HandlerAdapter处理器适配器。<br>5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。<br>6、 Controller执行完成返回ModelAndView。<br>7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。<br>8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。<br>9、 ViewReslover解析后返回具体View。<br>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。<br>11、 DispatcherServlet响应用户</p>
<p>以下是Spring MVC请求处理流程中涉及的英文术语及其中文音译对照表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>英文术语</th>
<th>中文音译（谐音参考）</th>
<th>实际含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DispatcherServlet</td>
<td>迪斯佩彻-色尔维特</td>
<td>前端控制器（中央调度器）</td>
</tr>
<tr>
<td>HandlerMapping</td>
<td>汉德勒-马平</td>
<td>处理器映射器（路由匹配器）</td>
</tr>
<tr>
<td>HandlerAdapter</td>
<td>汉德勒-阿达普特</td>
<td>处理器适配器（接口适配器）</td>
</tr>
<tr>
<td>Controller</td>
<td>康特罗勒</td>
<td>后端控制器（业务控制器）</td>
</tr>
<tr>
<td>ModelAndView</td>
<td>莫德尔-安德-维尤</td>
<td>模型和视图（数据视图容器）</td>
</tr>
<tr>
<td>ViewReslover</td>
<td>维尤-瑞佐尔沃</td>
<td>视图解析器（模板引擎管理器）</td>
</tr>
<tr>
<td>Interceptor</td>
<td>因特塞普特</td>
<td>拦截器（预处理/后处理组件）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="拦截器和控制器的区别"><a href="#拦截器和控制器的区别" class="headerlink" title="拦截器和控制器的区别"></a>拦截器和控制器的区别</h3><p>拦截器 vs 过滤器的区别?</p>
<ul>
<li>拦截器是springMVC组件，过滤器servlet的三大组件之一</li>
<li>拦截器只能对控制器请求起作用，而过滤器则可以对所有的请求起作用</li>
<li>拦截器可以直接获取IOC容器中的对象，而过滤器就不太方便获取</li>
</ul>
<h3 id="Spring框架中都用到了哪些设计模式"><a href="#Spring框架中都用到了哪些设计模式" class="headerlink" title="Spring框架中都用到了哪些设计模式"></a>Spring框架中都用到了哪些设计模式</h3><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；<br>（2）单例模式：Bean默认为单例模式。<br>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；<br>（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现—ApplicationListener</p>
<h3 id="Required-注解，-Autowired-注解，-Qualifier-注解，作用和区别"><a href="#Required-注解，-Autowired-注解，-Qualifier-注解，作用和区别" class="headerlink" title="@Required 注解，@Autowired 注解，@Qualifier 注解，作用和区别"></a>@Required 注解，@Autowired 注解，@Qualifier 注解，作用和区别</h3><p><strong>@Required</strong> 注解这个注解表明 bean 的属性必须在配置的时候设置，通过一个 bean 定义的显**式的属性值或通过自动装配，若@Required 注解的 bean 属性未被设置，容器将抛出BeanInitializationException。</p>
<p><strong>@Autowired</strong> 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required 一样，修饰 setter 方法、构造器、属性或者具有任意名称和/或多个参数的 PN 方法。<br><strong>@Qualifier</strong>当有多个相同类型的 bean 却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的<br>确切的 bean。</p>
<h3 id="Autowired-vs-Resource的区别"><a href="#Autowired-vs-Resource的区别" class="headerlink" title="@Autowired vs @Resource的区别"></a>@Autowired vs @Resource的区别</h3><p>● @Autowired是Spring框架提供的注解，而@Resource是JDK提供的注解。<br>● @Autowired默认是按照类型注入，@Resource是按照名称注入</p>
<h3 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<p>1、 程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</p>
<p>2、 声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML的配置来管理事务。</p>
<ul>
<li>XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ul>
<h2 id="Spring-Boot部分"><a href="#Spring-Boot部分" class="headerlink" title="Spring Boot部分"></a>Spring Boot部分</h2><h3 id="什么是-Spring-Boot？为什么要用SpringBoot？"><a href="#什么是-Spring-Boot？为什么要用SpringBoot？" class="headerlink" title="什么是 Spring Boot？为什么要用SpringBoot？"></a>什么是 Spring Boot？为什么要用SpringBoot？</h3><p>pring Boot是Spring官方推出的一个快速开发框架，他的优点非常的多例如：</p>
<p><strong>一、独立运行</strong><br>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。<br><strong>二、简化配置</strong><br>spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。</p>
<p><strong>三、自动配置</strong><br>Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。<br><strong>四、无代码生成和XML配置</strong><br>Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。<br><strong>五、应用监控</strong><br>Spring Boot提供一系列端点可以监控服务及应用，做健康检测</p>
<h3 id="Spring-Boot的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>启动类上面的注解是<code>@SpringBootApplication</code>，它也是 Spring Boot 的核心注解，主要组合包含了以下3 个注解：<br><code>@SpringBootConfiguration</code>：组合了 @Configuration 注解，实现配置文件的功能。<br><code>@EnableAutoConfiguration</code>：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：<br><code>@ComponentScan</code>：Spring组件扫描</p>
<h3 id="Spring-boot-配置文件有哪几种类型？"><a href="#Spring-boot-配置文件有哪几种类型？" class="headerlink" title="Spring boot 配置文件有哪几种类型？"></a>Spring boot 配置文件有哪几种类型？</h3><p>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</p>
<ol>
<li>application 是用户级别的配置文件，主要用于 Spring Boot 项目的自动化配置。</li>
<li>bootstrap 是系统级别的配置文件</li>
</ol>
<h3 id="如何理解-Spring-Boot-中的-Starters？"><a href="#如何理解-Spring-Boot-中的-Starters？" class="headerlink" title="如何理解 Spring Boot 中的 Starters？"></a>如何理解 Spring Boot 中的 Starters？</h3><p><strong>Starters是什么：</strong><br><u>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包</u>，你可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA访问数据库，只要加入springboot-starter-data-jpa启动器依赖就能使用了。Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。</p>
<p><strong>springboot常用的starter有哪些</strong></p>
<p>spring-boot-starter-<strong>web</strong> 嵌入tomcat和web开发需要servlet与jsp支持</p>
<p>spring-boot-starter-<strong>data-jpa</strong> 数据库支持</p>
<p>spring-boot-starter-<strong>data-redis</strong> redis数据库支持</p>
<p>spring-boot-starter-<strong>data-solr</strong> solr支持</p>
<p>mybatis-spring-boot-<strong>starter</strong> 第三方的mybatis集成starter</p>
<h3 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h3><p>基本上不需要，但是也可以部署到其他容器中，Spring Boot内置了Tomcat/ Jetty等容器</p>
<h3 id="Spring-Boot中的监视器是什么？"><a href="#Spring-Boot中的监视器是什么？" class="headerlink" title="Spring Boot中的监视器是什么？"></a>Spring Boot中的监视器是什么？</h3><p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态</p>
<h3 id="如何使用Spring-Boot实现异常处理？"><a href="#如何使用Spring-Boot实现异常处理？" class="headerlink" title="如何使用Spring Boot实现异常处理？"></a>如何使用Spring Boot实现异常处理？</h3><p>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法。 我们通过实现一个ControlerAdvice类，来处理控制器类抛出的所有异常</p>
<h3 id="如何理解-Spring-Boot-配置加载顺序"><a href="#如何理解-Spring-Boot-配置加载顺序" class="headerlink" title="如何理解 Spring Boot 配置加载顺序"></a>如何理解 Spring Boot 配置加载顺序</h3><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。<br>1）properties文件；<br>2）YAML文件；<br>3）系统环境变量；<br>4）命令行参数；<br>等等……</p>
<h3 id="Spring-Boot-的核心配置文件有哪几个？它们的区别是什么？"><a href="#Spring-Boot-的核心配置文件有哪几个？它们的区别是什么？" class="headerlink" title="Spring Boot 的核心配置文件有哪几个？它们的区别是什么？"></a>Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</h3><p>Spring Boot 的核心配置文件是 <code>application</code> 和 <code>bootstrap</code>配置文件。</p>
<p>application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。<br>bootstrap 配置文件有以下几个应用场景。</p>
<ol>
<li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置<br>信息；</li>
<li>一些固定的不能被覆盖的属性；</li>
<li>一些加密/解密的场景</li>
</ol>
<h3 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h3><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用JavaConfig 的优点在于：</p>
<p>1、面向对象的配置:由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。<br>2、减少或消除 XML 配置：基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。<br>3、类型安全和重构友好：JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xhayane.top">XH-Ayane</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xhayane.top/2025/08/08/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%AE%9D%E5%85%B8/">http://xhayane.top/2025/08/08/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%AE%9D%E5%85%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xhayane.top" target="_blank">XHAYANEの小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%AE%9D%E5%85%B8/">面试大宝典</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/09/20/u2w8Q45TqcpyLej.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/11/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%80%9F%E6%9F%A5/" title="Spring常用注解速查"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring常用注解速查</div></div></a></div><div class="next-post pull-right"><a href="/2025/08/07/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MyBatis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/09/20/u2w8Q45TqcpyLej.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XH-Ayane</div><div class="author-info__description">求知，探索，为自己放荡不羁的活着</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/178075368?spm_id_from=333.1007.0.0"><i></i><span>电波连接ing……</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XH-Ayane" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://1398136448@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/178075368?spm_id_from=333.1007.0.0" target="_blank" title="bilbil"><i class="fab fa-bilibili" style="color: #FF66B2;"></i></a><a class="social-icon" href="https://www.pixiv.net/users/51121543" target="_blank" title="pixiv"><i class="fab fa-pixiv" style="color: #24292e;"></i></a><a class="social-icon" href="https://x.com/AyaneXh" target="_blank" title="twitter"><i class="fab fa-x-twitter" style="color: ;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到本站，本站仍在建设中，文章编写及其业余，正在努力加油</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%AE%9D%E5%85%B8"><span class="toc-number">1.</span> <span class="toc-text">个人整理面试超级大宝典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">面向对象的设计原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFB-S%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFC-S%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是B&#x2F;S架构，什么是C&#x2F;S架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">Java语言的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.3.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">java中常见的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">java中的几种数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BB%80%E4%B9%88%E6%98%AF%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.6.</span> <span class="toc-text">讲讲什么是显示转换，什么是隐式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%86%E8%A3%85%E7%AE%B1%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.1.7.</span> <span class="toc-text">什么是拆装箱机制？什么是包装类？为什么要使用包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-number">1.1.8.</span> <span class="toc-text">面向对象的特征有哪些方面？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1-Abstraction"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">1. 抽象 (Abstraction)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85-Encapsulation"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">2. 封装 (Encapsulation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF-Inheritance"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">3. 继承 (Inheritance)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%9A%E6%80%81-Polymorphism"><span class="toc-number">1.1.8.4.</span> <span class="toc-text">4. 多态 (Polymorphism)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.8.5.</span> <span class="toc-text">多态类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.8.6.</span> <span class="toc-text">实现多态的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.8.7.</span> <span class="toc-text">多态示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6public%EF%BC%8Cprivate-protected-%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%86%99%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.9.</span> <span class="toc-text">访问修饰符public，private,protected,以及不写时的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-number">1.1.10.</span> <span class="toc-text">String是最基本的数据类型吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-Overload-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.11.</span> <span class="toc-text">方法重写(Override)与方法重载(Overload)的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-Override"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">方法重写(Override)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.12.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-Overload"><span class="toc-number">1.1.12.1.</span> <span class="toc-text">方法重载(Overload)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.1.13.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.13.1.</span> <span class="toc-text">重写与重载的关键区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E6%8A%80%E5%B7%A7"><span class="toc-number">1.1.13.2.</span> <span class="toc-text">记忆技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.14.</span> <span class="toc-text">equals与&#x3D;&#x3D;的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">1.1.14.1.</span> <span class="toc-text">&#x3D;&#x3D;（运算符）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals-%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">1.1.14.2.</span> <span class="toc-text">equals()（方法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99"><span class="toc-number">1.1.14.3.</span> <span class="toc-text">✅ 黄金法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E5%85%B8%E5%9E%8B%E9%99%B7%E9%98%B1"><span class="toc-number">1.1.14.4.</span> <span class="toc-text">⚠️ 典型陷阱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.1.15.</span> <span class="toc-text">java的各种数据默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%B8%B8%E7%94%A8%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.16.</span> <span class="toc-text">java常用包有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">1.1.17.</span> <span class="toc-text">java中的是值传递还是引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.18.</span> <span class="toc-text">形参与实参的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.18.1.</span> <span class="toc-text">本质区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.18.2.</span> <span class="toc-text">五大核心区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%EF%BC%88Object%E7%B1%BB%EF%BC%89"><span class="toc-number">1.1.19.</span> <span class="toc-text">Java关键方法（Object类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92-vs-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">1.1.20.</span> <span class="toc-text">值传递 vs 引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stetic%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.21.</span> <span class="toc-text">Stetic关键字有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%9C%A8java%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-number">1.1.22.</span> <span class="toc-text">final在java中的作用，有哪些用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringString-StringBuffffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.23.</span> <span class="toc-text">StringString StringBuffffer 和 StringBuilder 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.24.</span> <span class="toc-text">String类的常用方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%98%AF%E5%8D%95%E7%BB%A7%E6%89%BF%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.25.</span> <span class="toc-text">java中的继承是单继承还是多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Super%E4%B8%8Ethis%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.26.</span> <span class="toc-text">Super与this表示什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.27.</span> <span class="toc-text">抽象类和接口的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashcode%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.28.</span> <span class="toc-text">Hashcode的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.29.</span> <span class="toc-text">hashcode的实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.30.</span> <span class="toc-text">HashMap的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%EF%BC%9F"><span class="toc-number">1.1.31.</span> <span class="toc-text">java创建对象的方式有？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.32.</span> <span class="toc-text">拷贝和浅拷贝的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E3%80%81finalize-%E3%80%81finally"><span class="toc-number">1.1.33.</span> <span class="toc-text">final、finalize()、finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC%E6%93%8D%E4%BD%9C%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.34.</span> <span class="toc-text">JDBC操作的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8jdbc%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%87%BA%E7%8E%B0sql%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">1.1.35.</span> <span class="toc-text">在使用jdbc的时候，如何防止出现sql注入的问题。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.1.36.</span> <span class="toc-text">是否了解连接池，使用连接池的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CDUP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.37.</span> <span class="toc-text">TCP和DUP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.1.38.</span> <span class="toc-text">TCP的三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.39.</span> <span class="toc-text">tcp 为什么要三次握手，两次不行吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.40.</span> <span class="toc-text">GET请求和POST请求区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTomCat"><span class="toc-number">1.1.41.</span> <span class="toc-text">什么是TomCat?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFServlet%EF%BC%9FServlet%E7%94%B1%E8%B0%81%E6%9D%A5%E5%88%9B%E5%BB%BA%EF%BC%9FServlet%E6%96%B9%E6%B3%95%E7%94%B1%E8%B0%81%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.42.</span> <span class="toc-text">什么是Servlet？Servlet由谁来创建？Servlet方法由谁调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.43.</span> <span class="toc-text">Servlet的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91"><span class="toc-number">1.1.44.</span> <span class="toc-text">什么是请求转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.45.</span> <span class="toc-text">请求转发的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.46.</span> <span class="toc-text">请求重定向的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-amp-Session%E7%9A%84%E7%94%A8%E9%80%94%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.47.</span> <span class="toc-text">Cookie &amp; Session的用途和区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.48.</span> <span class="toc-text">Filter是什么，什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Listener%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.49.</span> <span class="toc-text">Listener是什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AJAX%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.50.</span> <span class="toc-text">AJAX是什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.51.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.52.</span> <span class="toc-text">TCP&#x2F;IP四层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BB%80%E4%B9%88%E5%8F%AB%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.53.</span> <span class="toc-text">静态内部类如何定义，什么叫成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F%E8%AF%B7%E5%88%97%E4%B8%BE"><span class="toc-number">1.1.54.</span> <span class="toc-text">排序都有哪几种方法？请列举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E5%87%BA%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%8C%85%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%AF%B7%E5%90%84%E4%B8%BE5%E4%B8%AA"><span class="toc-number">1.1.55.</span> <span class="toc-text">说出一些常用的类，包，接口，请各举5个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="toc-number">1.1.56.</span> <span class="toc-text">Java 中会存在内存泄漏吗，请简单描述。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="toc-number">1.1.57.</span> <span class="toc-text">如何实现对象克隆？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E2%80%9D-java%E2%80%9D%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%88%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">1.1.58.</span> <span class="toc-text">一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">集合、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8ClinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">ArrayList和linkedList的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E5%8C%85%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%8ECollections%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">Collection包结构，与Collections的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%B4%E4%B8%80%E4%B8%8BList%EF%BC%8CSet-Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.4.</span> <span class="toc-text">简单的说一下List，Set,Map三者的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">Java中异常分为哪两种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">异常的处理机制有几种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E8%80%8C%E8%A8%80try-catch-fifinally%EF%BC%8Ctry%E9%87%8C%E6%9C%89return%EF%BC%8Cfinally%E8%BF%98%E6%89%A7%E8%A1%8C%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">关于异常而言try catch fifinally，try里有return，finally还执行么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thow%E4%B8%8Ethorws%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.4.</span> <span class="toc-text">Thow与thorws区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E5%92%8Cexception%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.5.</span> <span class="toc-text">error和exception有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-amp-amp-NIO"><span class="toc-number">1.4.</span> <span class="toc-text">IO&amp;&amp; NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84IO%E6%B5%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">java中的IO流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84IO%E5%92%8CNIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.</span> <span class="toc-text">java中的IO和NIO的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.</span> <span class="toc-text">字节流和字符流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javaNIO"><span class="toc-number">1.4.4.</span> <span class="toc-text">javaNIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.4.5.</span> <span class="toc-text">NIO的缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.5.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">java反射的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">反射的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0java%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB%E4%B8%BA%EF%BC%9A"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">可以实现java反射的类为：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%91%A2"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">如何通过反射机制来创建对象实例呢</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是Java序列化，如何实现Java序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98-%E6%8C%81%E4%B9%85%E5%8C%96-%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%8A%B6%E6%80%81%E5%88%B0%E5%86%85%E5%AD%98%E6%88%96%E8%80%85%E7%A3%81%E7%9B%98"><span class="toc-number">1.6.2.</span> <span class="toc-text">保存(持久化)对象及其状态到内存或者磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E4%BF%9D%E6%8C%81-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8D%E4%BF%9D%E5%AD%98"><span class="toc-number">1.6.3.</span> <span class="toc-text">序列化对象以字节数组保持-静态成员不保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E4%BC%A0%E8%BE%93"><span class="toc-number">1.6.4.</span> <span class="toc-text">序列化用户远程对象传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.7.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%A0%87%E5%87%86%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%88%E7%94%A8%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%89%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">Java中的四种标准元注解（用于注解其他注解的注解）包括：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="toc-number">1.8.</span> <span class="toc-text">多线程并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">多线程的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">如何停止一个正在运行的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.3.</span> <span class="toc-text">线程基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E5%92%8Cwait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%E7%82%B9"><span class="toc-number">1.8.4.</span> <span class="toc-text">sleep()和wait()有什么异同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E4%B8%8Eyield-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.5.</span> <span class="toc-text">sleep()与yield()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Theard%E7%B1%BB%E4%B8%AD%E7%9A%84Yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.8.6.</span> <span class="toc-text">Theard类中的Yield方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E4%B8%8Ejoin-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.7.</span> <span class="toc-text">sleep()与join()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-%E5%92%8CnotifyAll%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.8.</span> <span class="toc-text">notify()和notifyAll有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.8.9.</span> <span class="toc-text">什么是线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.10.</span> <span class="toc-text">什么是线程池，线程池的优点，线程池的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.11.</span> <span class="toc-text">终止线程的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.12.</span> <span class="toc-text">实现线程同步的三个方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.12.1.</span> <span class="toc-text">采用同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.12.2.</span> <span class="toc-text">采用同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8-Lock-%E9%94%81%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.8.12.3.</span> <span class="toc-text">采用 Lock 锁对象实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#start-%E5%92%8Crun-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.13.</span> <span class="toc-text">start()和run()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.8.14.</span> <span class="toc-text">java后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E8%AF%B7%E8%AF%B4%E8%8B%B1%E6%96%87%E2%80%94%E4%B8%AD%E6%96%87%EF%BC%89"><span class="toc-number">1.8.15.</span> <span class="toc-text">常用线程池（请说英文—中文）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FixedThreadPool%EF%BC%88%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">1.8.15.1.</span> <span class="toc-text">FixedThreadPool（固定大小线程池）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CachedThreadPool%EF%BC%88%E7%BC%93%E5%AD%98%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">1.8.15.2.</span> <span class="toc-text">CachedThreadPool（缓存线程池）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SingleThreadExecutor%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">1.8.15.3.</span> <span class="toc-text">SingleThreadExecutor（单线程池）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScheduledThreadPool%EF%BC%88%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">1.8.15.4.</span> <span class="toc-text">ScheduledThreadPool（定时任务线程池）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A1%86%E6%9E%B6"><span class="toc-number">1.8.16.</span> <span class="toc-text">java中线程池框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.17.</span> <span class="toc-text">线程池七大核心参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.8.18.</span> <span class="toc-text">工作队列类型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue%EF%BC%88%E6%9C%89%E7%95%8C%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.8.18.1.</span> <span class="toc-text">ArrayBlockingQueue（有界队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue%EF%BC%88%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.8.18.2.</span> <span class="toc-text">LinkedBlockingQueue（无界队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue%EF%BC%88%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.8.18.3.</span> <span class="toc-text">SynchronousQueue（同步队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityBlockingQueue%EF%BC%88%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.8.18.4.</span> <span class="toc-text">PriorityBlockingQueue（优先级队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DelayedWorkQueue%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.8.18.5.</span> <span class="toc-text">DelayedWorkQueue（延迟队列）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.19.</span> <span class="toc-text">拒绝策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AbortPolicy%EF%BC%88%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%89"><span class="toc-number">1.8.19.1.</span> <span class="toc-text">AbortPolicy（抛出异常）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CallerRunsPolicy%EF%BC%88%E8%B0%83%E7%94%A8%E8%80%85%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">1.8.19.2.</span> <span class="toc-text">CallerRunsPolicy（调用者执行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardPolicy%EF%BC%88%E4%B8%A2%E5%BC%83%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-number">1.8.19.3.</span> <span class="toc-text">DiscardPolicy（丢弃任务）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardOldestPolicy%EF%BC%88%E4%B8%A2%E5%BC%83%E6%9C%80%E8%80%81%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-number">1.8.19.4.</span> <span class="toc-text">DiscardOldestPolicy（丢弃最老任务）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.19.5.</span> <span class="toc-text">自定义拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.8.20.</span> <span class="toc-text">如何选择合适的线程池大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98%E6%8A%80%E5%B7%A7"><span class="toc-number">1.8.21.</span> <span class="toc-text">线程池调优技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.8.22.</span> <span class="toc-text">什么是乐观锁，什么是悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.23.</span> <span class="toc-text">线程与进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.8.24.</span> <span class="toc-text">什么是多线程中的上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.25.</span> <span class="toc-text">Java 中用到的线程调度算法是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">1.9.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.1.</span> <span class="toc-text">Java 中的四种引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">常见垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-GC%EF%BC%9F"><span class="toc-number">1.9.3.</span> <span class="toc-text">GC 是什么？为什么要有 GC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E4%BB%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.4.</span> <span class="toc-text">Java堆内存的分代设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-jvm-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E5%88%97%E5%87%BA%E5%87%A0%E7%A7%8D%E5%B0%B1%E5%8F%AF%E4%BB%A5%EF%BC%89"><span class="toc-number">1.9.5.</span> <span class="toc-text">常用的 jvm 调优的参数都有哪些？（列出几种就可以）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-jvm-%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">1.9.6.</span> <span class="toc-text">说一下 jvm 调优的工具？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.7.</span> <span class="toc-text">加载class文件的原理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.8.</span> <span class="toc-text">堆内存和栈内存的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.9.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86"><span class="toc-number">1.9.10.</span> <span class="toc-text">JVM内存模型包括哪些部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.9.11.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.9.12.</span> <span class="toc-text">synchronized 和 volatile 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-Lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.13.</span> <span class="toc-text">synchronized 和 Lock 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis"><span class="toc-number">1.10.</span> <span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Mybatis%EF%BC%9F"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是 Mybatis？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.2.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C-%E5%92%8C-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.10.3.</span> <span class="toc-text">“#{}和${}”的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis-%E5%8A%A8%E6%80%81-sql-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-sql%EF%BC%9F"><span class="toc-number">1.10.4.</span> <span class="toc-text">Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">1.10.5.</span> <span class="toc-text">MyBatis 实现一对一有几种方式?具体怎么操作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">1.10.6.</span> <span class="toc-text">MyBatis 实现一对多有几种方式,怎么操作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis-%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">1.10.7.</span> <span class="toc-text">Mybatis 的一级、二级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mybatis-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.10.8.</span> <span class="toc-text">mybatis 有几种分页方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86"><span class="toc-number">1.11.</span> <span class="toc-text">数据库部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.11.1.</span> <span class="toc-text">数据库存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.2.</span> <span class="toc-text">InnoDB与MyISAM的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.11.3.</span> <span class="toc-text">什么是索引，索引的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.4.</span> <span class="toc-text">数据库的三范式是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F%E5%88%86%E5%88%AB%E5%A4%84%E7%90%86%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.5.</span> <span class="toc-text">什么是数据库事务？事务的特性有哪些？事务的隔离级别？分别处理那些问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.6.</span> <span class="toc-text">事务的并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9SQL%E4%BC%98%E5%8C%96"><span class="toc-number">1.11.7.</span> <span class="toc-text">如何对SQL优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E8%AF%B4drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.8.</span> <span class="toc-text">简单说一说drop、delete与truncate的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.11.9.</span> <span class="toc-text">什么是视图，视图的优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.11.10.</span> <span class="toc-text">多表查询的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.11.</span> <span class="toc-text">并发事务带来哪些问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%87%E4%B8%8A%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.11.12.</span> <span class="toc-text">遇上大表如何优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E7%AD%96%E7%95%A5"><span class="toc-number">1.11.13.</span> <span class="toc-text">数据库并发策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="toc-number">1.11.14.</span> <span class="toc-text">MySQL 中有哪几种锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CHAR-%E5%92%8C-VARCHAR-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.11.15.</span> <span class="toc-text">CHAR 和 VARCHAR 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%8C%E8%A8%80%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%98%AF%E7%9B%B8%E5%BD%93%E9%87%8D%E8%A6%81%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E8%AF%B7%E5%9B%9E%E7%AD%94%E6%9C%89%E5%85%B3%E7%B4%A2%E5%BC%95%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.16.</span> <span class="toc-text">对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.11.16.1.</span> <span class="toc-text">1、索引的目的是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B4%9F%E9%9D%A2%E5%BD%B1%E5%93%8D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.11.16.2.</span> <span class="toc-text">2、索引对数据库系统的负面影响是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.11.16.3.</span> <span class="toc-text">3、为数据表建立索引的原则有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E5%AE%9C%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%9C%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.11.16.4.</span> <span class="toc-text">4、什么情况下不宜建立索引？什么情况下宜建立索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.16.5.</span> <span class="toc-text">5、索引的优缺点是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E8%AF%AD%E8%A8%80%E5%8C%85%E6%8B%AC%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%EF%BC%9F%E6%AF%8F%E9%83%A8%E5%88%86%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%85%B3%E9%94%AE"><span class="toc-number">1.11.17.</span> <span class="toc-text">SQL 语言包括哪几部分？每部分都有哪些操作关键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-SQL-%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.11.18.</span> <span class="toc-text">说说对 SQL 语句优化有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81"><span class="toc-number">1.11.19.</span> <span class="toc-text">什么是锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">1.11.20.</span> <span class="toc-text">什么是时间戳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINUX%E9%83%A8%E5%88%86"><span class="toc-number">1.12.</span> <span class="toc-text">LINUX部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%94%A8%E4%BB%80%E4%B9%88%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%EF%BC%9F%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E3%80%81%E4%B8%8A%E5%B1%82%E7%9B%AE%E5%BD%95%E7%94%A8%E4%BB%80%E4%B9%88%E8%A1%A8%E7%A4%BA%EF%BC%9F%E4%B8%BB%E7%9B%AE%E5%BD%95%E7%94%A8%E4%BB%80%E4%B9%88%E8%A1%A8%E7%A4%BA-%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.12.1.</span> <span class="toc-text">绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%EF%BC%9F%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E9%80%80%E5%87%BA%EF%BC%9F%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="toc-number">1.12.2.</span> <span class="toc-text">怎么查看当前进程？怎么执行退出？怎么查看当前路径？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%B8%85%E5%B1%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E9%80%80%E5%87%BA%E5%BD%93%E5%89%8D%E5%91%BD%E4%BB%A4%EF%BC%9F%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9D%A1%E7%9C%A0%EF%BC%9F%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7-id%EF%BC%9F%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A%E5%B8%AE%E5%8A%A9%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.12.3.</span> <span class="toc-text">怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ls-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%EF%BC%9F-%E5%8F%AF%E4%BB%A5%E5%B8%A6%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.12.4.</span> <span class="toc-text">Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E5%91%BD%E4%BB%A4"><span class="toc-number">1.12.5.</span> <span class="toc-text">列举几个常用的Linux命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%A9%BA%E9%97%B4%EF%BC%9F-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E5%91%A2"><span class="toc-number">1.12.6.</span> <span class="toc-text">使用什么命令查看磁盘使用空间？ 空闲空间呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%A6%E8%BF%9E%E9%80%9A-%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B-ip-%E5%9C%B0%E5%9D%80%E5%8F%8A%E6%8E%A5%E5%8F%A3%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.12.7.</span> <span class="toc-text">使用什么命令查看网络是否连通,使用什么命令查看 ip 地址及接口信息？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%90%84%E7%B1%BB%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4"><span class="toc-number">1.12.8.</span> <span class="toc-text">查看各类环境变量用什么命令?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">1.13.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">1.13.1.</span> <span class="toc-text">使用Redis有哪些好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.13.2.</span> <span class="toc-text">Redis的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.13.3.</span> <span class="toc-text">什么是Redis事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E3%80%81%E7%AD%89%E9%97%AE%E9%A2%98"><span class="toc-number">1.13.4.</span> <span class="toc-text">缓存雪崩、缓存穿透、缓存预热、等问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.13.5.</span> <span class="toc-text">Redis 持久化有几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%98%AF%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">1.13.6.</span> <span class="toc-text">Redis是单进程单线程的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">1.13.7.</span> <span class="toc-text">单线程的redis为什么这么快</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%83%A8%E5%88%86"><span class="toc-number">1.14.</span> <span class="toc-text">操作系统部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.1.</span> <span class="toc-text">并发和并行的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text">线程和进程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%94%A8%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.15.1.</span> <span class="toc-text">Java用到的线程调度算法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6-Thread-Scheduler-%E5%92%8C%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87-Time-Slicing"><span class="toc-number">1.15.2.</span> <span class="toc-text">什么是线程调度(Thread Scheduler)和时间分片(Time Slicing )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E9%83%A8%E5%88%86"><span class="toc-number">1.16.</span> <span class="toc-text">spring部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring%EF%BC%9Fspring%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.16.1.</span> <span class="toc-text">什么是spring？spring的核心机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E6%9C%89%E9%82%A3%E5%87%A0%E9%83%A8%E5%88%86%E6%9E%84%E6%88%90"><span class="toc-number">1.16.2.</span> <span class="toc-text">spring中有多少个模块？有那几部分构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E7%9A%84IOC%E5%92%8CAOP%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%99%E4%B8%AA%E7%9B%B8%E5%BD%93%E7%9A%84%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.16.3.</span> <span class="toc-text">Spring的IOC和AOP机制（这个相当的重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.16.4.</span> <span class="toc-text">AOP 有哪些实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E7%BC%96%E7%BB%87%EF%BC%9F"><span class="toc-number">1.16.5.</span> <span class="toc-text">何为编织？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">1.16.6.</span> <span class="toc-text">什么是依赖注入？可以通过多少种方式完成依赖注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.16.7.</span> <span class="toc-text">spring 提供了哪些配置方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E5%9B%9B%E5%A4%A7%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.16.8.</span> <span class="toc-text">spring四大注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.16.9.</span> <span class="toc-text">Spring中重要的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired%E5%92%8CResource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.10.</span> <span class="toc-text">Autowired和Resource的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-bean%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.16.11.</span> <span class="toc-text">spring bean容器的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.16.12.</span> <span class="toc-text">自动装配有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%97%E8%A1%A8%EF%BC%88%E8%83%8C%E5%B8%B8%E8%A7%81%E9%82%A3%E5%87%A0%E4%B8%AA%E5%B0%B1%E8%A1%8C%EF%BC%89"><span class="toc-number">1.16.13.</span> <span class="toc-text">设计模式列表（背常见那几个就行）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Aspect%EF%BC%9F%E5%88%87%E7%82%B9%EF%BC%9F%E9%80%9A%E7%9F%A5%EF%BC%9F"><span class="toc-number">1.16.14.</span> <span class="toc-text">什么是 Aspect？切点？通知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.16.15.</span> <span class="toc-text">MVC模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-MVC%E3%80%81MVVM-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.16.</span> <span class="toc-text">简述 MVC、MVVM 的关系与区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ORM%E6%80%9D%E6%83%B3"><span class="toc-number">1.16.17.</span> <span class="toc-text">ORM思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.16.18.</span> <span class="toc-text">Spring MVC框架的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DispatcherServlet-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88Spring-MVC%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">1.16.19.</span> <span class="toc-text">DispatcherServlet 的工作流程（Spring MVC流程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.20.</span> <span class="toc-text">拦截器和控制器的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.16.21.</span> <span class="toc-text">Spring框架中都用到了哪些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Required-%E6%B3%A8%E8%A7%A3%EF%BC%8C-Autowired-%E6%B3%A8%E8%A7%A3%EF%BC%8C-Qualifier-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.22.</span> <span class="toc-text">@Required 注解，@Autowired 注解，@Qualifier 注解，作用和区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired-vs-Resource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.23.</span> <span class="toc-text">@Autowired vs @Resource的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E4%B8%BE-spring-%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.16.24.</span> <span class="toc-text">列举 spring 支持的事务管理类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot%E9%83%A8%E5%88%86"><span class="toc-number">1.17.</span> <span class="toc-text">Spring Boot部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Boot%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8SpringBoot%EF%BC%9F"><span class="toc-number">1.17.1.</span> <span class="toc-text">什么是 Spring Boot？为什么要用SpringBoot？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%B1%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">1.17.2.</span> <span class="toc-text">Spring Boot的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.17.3.</span> <span class="toc-text">Spring boot 配置文件有哪几种类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E4%B8%AD%E7%9A%84-Starters%EF%BC%9F"><span class="toc-number">1.17.4.</span> <span class="toc-text">如何理解 Spring Boot 中的 Starters？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">1.17.5.</span> <span class="toc-text">Spring Boot 需要独立的容器运行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot%E4%B8%AD%E7%9A%84%E7%9B%91%E8%A7%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.17.6.</span> <span class="toc-text">Spring Boot中的监视器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Spring-Boot%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.17.7.</span> <span class="toc-text">如何使用Spring Boot实现异常处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.17.8.</span> <span class="toc-text">如何理解 Spring Boot 配置加载顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.17.9.</span> <span class="toc-text">Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JavaConfig%EF%BC%9F"><span class="toc-number">1.17.10.</span> <span class="toc-text">什么是 JavaConfig？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/12/SpringMVC%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/" title="SpringMVC">SpringMVC</a><time datetime="2025-08-12T14:25:00.000Z" title="发表于 2025-08-12 14:25:00">2025-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/11/Spring%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/" title="Spring">Spring</a><time datetime="2025-08-11T14:25:00.000Z" title="发表于 2025-08-11 14:25:00">2025-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/11/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%80%9F%E6%9F%A5/" title="Spring常用注解速查">Spring常用注解速查</a><time datetime="2025-08-11T14:25:00.000Z" title="发表于 2025-08-11 14:25:00">2025-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/08/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%AE%9D%E5%85%B8/" title="个人整理面试大宝典">个人整理面试大宝典</a><time datetime="2025-08-08T14:25:00.000Z" title="发表于 2025-08-08 14:25:00">2025-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/07/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MyBatis学习笔记">MyBatis学习笔记</a><time datetime="2025-08-07T14:25:00.000Z" title="发表于 2025-08-07 14:25:00">2025-08-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2024/11/05/Ilzbr3XJBLg9e4S.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By XH-Ayane</div><div class="footer_custom_text">Melancholy and silence define me, but I aim to be my own light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script async src="/js/title.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="/js/fps.js"></script><script defer src="/js/cursor.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2025/07/14/java快速学习速查（7）[进阶篇]/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-07-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2025/07/14/java快速学习速查（7）[进阶篇]/&quot;);" href="javascript:void(0);" alt="">java快速学习速查（7）[进阶篇]</a><div class="blog-slider__text">JBDC,SQL对象,数据库工具类，DAO结构,反射详解，注解详解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2025/07/14/java快速学习速查（7）[进阶篇]/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2025/07/09/java快速学习速查（6）[进阶篇]/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-07-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2025/07/09/java快速学习速查（6）[进阶篇]/&quot;);" href="javascript:void(0);" alt="">java快速学习速查（6）[进阶篇]</a><div class="blog-slider__text">涉及文件，IO流，线程，锁，网络编程等</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2025/07/09/java快速学习速查（6）[进阶篇]/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（1）/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-31</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（1）/&quot;);" href="javascript:void(0);" alt="">java快速学习速查（1）</a><div class="blog-slider__text">涉及Java基础语法，注释，对象和类，基本数据类型</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（1）/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（2）/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-31</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（2）/&quot;);" href="javascript:void(0);" alt="">java快速学习速查（2）</a><div class="blog-slider__text">变量类型，变量命名规则，修饰符，运算符</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（2）/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（3）/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-31</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（3）/&quot;);" href="javascript:void(0);" alt="">java快速学习速查（3）</a><div class="blog-slider__text">循环结构，条件语句，switch case,Number&amp;Math,Character,String,StringBuffer几个方面</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2025/03/31/java快速学习速查（3）/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2025/04/01/java快速学习速查（4）/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2025/04/01/java快速学习速查（4）/&quot;);" href="javascript:void(0);" alt="">java快速学习速查（4）</a><div class="blog-slider__text">数组，日期时间，正则表达式，方法，构造方法，Stream和File和IO，scanner类，异常处理</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2025/04/01/java快速学习速查（4）/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2025/04/01/java快速学习速查（5）/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2025/04/01/java快速学习速查（5）/&quot;);" href="javascript:void(0);" alt="">java快速学习速查（5）</a><div class="blog-slider__text">Java面向对象部分的全部数据类型，继承，重载，多态，抽象类，封装，接口，枚举，包，反射</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2025/04/01/java快速学习速查（5）/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>